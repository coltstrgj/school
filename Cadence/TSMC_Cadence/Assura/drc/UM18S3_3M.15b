/* ******************************************************************************
;  *  0.18um ASSURA DRC COMMAND FILE - UM18S3_3M.15b  (08/3/07)      *
;  *  FOR TSMC 0.18um MIXED SIGNAL/RF 1P3M SALICIDE 1.8V/3.3V PROCESS           *
;  *  DESIGN RULE DOCUMENT: T-018-MM-DR-001 Rev1.5                              *
;  *                        T-018-LO-DR-001 Rev2.6                              *
;  ******************************************************************************
;  DISCLAIMER
;
;  The information contained herein is provided by TSMC on an "AS IS" basis
;  without any warranty, and TSMC has no obligation to support or otherwise
;  maintain the information.  TSMC disclaims any representation that the
;  information does not infringe any intellectual property rights or proprietary
;  rights of any third parties.  There are no other warranties given by TSMC,
;  whether express, implied or statutory, including, without limitation, implied
;  warranties of merchantability and fitness for a particular purpose.
;
;  STATEMENT OF USE
;
;  This information contains confidential and proprietary information of TSMC.
;  No part of this information may be reproduced, transmitted, transcribed,
;  stored in a retrieval system, or translated into any human or computer
;  language, in any form or by any means, electronic, mechanical, magnetic,
;  optical, chemical, manual, or otherwise, without the prior written permission
;  of TSMC.  This information was prepared for informational purpose and is for
;  use by TSMC's customers only.  TSMC reserves the right to make changes in the
;  information at any time and without notice.
;
;-----------------------------------------------------------------------------------
;
;   NOTICE: (Read Me First!)
;
;   1. The error output are divided into two groups: errors
;      and recommendations which are reported to the output
;      layer 63 and 64 respectively.
;    - Errors are corresponding to the rule violations. Any
;      violation will stop the mask making.
;    - Recommendations are suggestions for design guideline.
;      It is only for reference.
;
;   2. If the input GDS file does not include all the layers in the
;      INPUT LAYER BLOCK, for example, they are generated by logic
;      operations, please make sure the consistence with original
;      layer definition.
;
;   3. N2V/P2V/N3V/P3V layers of TSMC library is generated by logic operation.
;
;---------------------------------------------------------------
;
;   REVISION:
;   1.3a 04/26/04 Yating Chuang   
;       Newly created.
;   1.3b.pre 02/20/04 Chris Yao
;	1) Take off DNW.I.2&DNW.I.3. 
;	2) Modify DNW.E.1: DNW can be fully covered by NW(see DNW.I.1).
;	3) Revise _PO.W.1.MM: change min. resistor width to 1um 
;	4) Revise HRI.C.2: change "unrelated PP region" to PP region only. 
;	5) Modify CTM.I.3: metal routing is allowed under CTM.      
;	6) Modify _NT_N.I.4.MM&_NT_N.E.1.MM: exclude application for inductor 
;	7) Modify _M6T.I.1/_M6T.I.2: allow Mtop-2 inside INDDMY if use 3 terminals inductor, 
;	   and allow M1 substrate pick up node inside INDDMY. 
;	8) Modify _M6T.E.3: add ABUT > 0 for PDK layout.
;   1.3b 08/31/05 Allen Tsai
;	1) Modify CTM.I.4: exclude well pick-up and poly connection under CTM.
;	2) Modify M6T.C.1: form inductor more exactly.
;   1.4a.pre 12/01/05 Allen Tsai
;	1) Redefine the region of CBM as size CTM by 2 (BPM5B) 
;	2) Enhance _NT_N.E.1.MM by modify OD to NPOD
;	3) Enhance CTM.S.6 CTM.E.2 CTM.S.3
;	4) Modify DNW.E.1 to check all DNW.
;   1.4a.pre 05/18/06 Y.J. Chuang
;	1) Move CTM.I.4, DNW.I.1, DNW.E.1 to recommended rule.
;	2) Refine NT_N.I.4.MM, DNW.C.4
;	3) Add DNW.E.2.
;	4) Remove DNW.C.2, DNW.C.3.M
;	5) Refine VTMN.I.3, VTMP.I.3
;   1.5a.pre 05/31/07 Y. L. Liu
;	1) Follow DRM revision and refine rule wording.
;	2) Remove DNW.I.1: check by DNW.E.1.
;	3) Remove _NT_N.I.4.MM and _NT_N.E.1.MM: check by NT_N.I.3 and NT_N.E.1 in Logic section.
;	4) Add Poly Resistor rules to recommended rule.
;	5) Rename CTM rules to CTM, MIM_Mx, and MIMVIA rules.
;	6) Rename M6T rules to UTM rules.
;	7) Add MIM Antenna rules.
;   1.5a 06/12/07 Y. L. Liu
;	-) Official release
;   1.5b 08/03/07 Y.L. Liu
;	-) Fix df2 layer missing
;
;**********************************************************************************************
;
;  DUMMY LAYER REQUIRED:
;
;  1) HOTWL   - Hot N-Well
;               N-Well not connected to the most positive voltage Vdd is defined as Hot N-Well. 
;               It must follow different width and space rules from the N-Well connected to 
;               Vdd (Cold N-Well). Use "HOTWL" layer to exactly cover the Hot N-Well area for 
;               correct N-Well DRC.
;
;  2) EXCL    - unDRC area
;               If there's any area with different rules and not to be checked in this run, 
;               use the "EXCL" layer to exactly cover the area to be excluded.
;
;  3) SDI     - I/O ESD Protection Circuit
;               For I/O guidance rule checking, use "SDI" layer to designate the ESD area to 
;               checked. The whole ESD devices should be covered by "SDI".
;
;  4) DPDMY   - Dummy Pad area
;               For chip corner dummy pad, use "DPDUMMY" layer to cover dummy pad area.
;
;  5) PLDMY   - Power Line
;               For chip corner power line, use "PLDUMMY" layer to cover whole power line area.
;
;  6) RWDMY   - NWell Resistor
;               The N-Well region covered by both RWDMY and RPO is the NW within OD resistor.
;               The N-Well region covered by only RWDMY is the NW under STI resistor.
;
;  7) DRCDMY  - TSMC reserved layer
; 
;  8) ESD1DMY - IO ESD region dummy layer, RPO must enclose whole gate
;     ESD2DMY - RPO enclose gate 0.05 for 3.3V
;
;  9) DMN2V   - dummy layer to avoid N2V in N+ poly resistor
;     DMP2V   - dummy layer to avoid P2V in P+ poly resistor
;
; 10) ESEXCL  - dummy layer to cover SRAM cell.
;
; 11) RLPPDMY - LPP high resistance poly resistor
;               Use "RLPPDMY" to exactly cover LPP high resistance poly resistor area.
;
; 12) WBDMY   - dummy layer to cover the CUP pad
; 
; 13) CTMDMY  - Capacitor bottom plate
;               Use "CTMDMY" to cover capacitor bottom plate
;	        Used in mixed-signal process.
; 
; 14) INDDMY  - dummy layer for inductor 
;               Used in mixed-signal process.
; 
;**********************************************************************************************
;
;                      CURRENT STATUS
;
;  RULES NOT IMPLEMENTED:
;
; The following rules are not coded in this rule file:
;
; rule                      description/explanation/alternate file
; ------------------------  ----------------------------------------------------
; Part I recommendations    Not coded (page 3 of spec.)
; 
; Antenna rules             Please refer to antenna DRC deck.
;
; Passivation rules         Please refer to Bound PAD DRC deck.
;
; Seal ring rules 	     not coded.
;
; Chip corner Power Line    Only ADP.1/ADP.S.1/ADP.C.1/ADP.C.2/ADP.E.1
; and Dummy PAD             /ADP.W.1/ADP.W.2/ADP.S.4/ADP.C.3/ADP.E.2 
;			     rules are coded.
;  
; * Guidelines implemented :
;
;     1) Partial I/O ESD GuideLine implemented: 4,5,6,9
;        Others don't be implemented because of guideline.
;
;     2) Partial LatchUp GuideLine implemented: 2,3
;        Others don't be implemented because of guideline.      
;
;     3) Dummy PAD Guidline implemented: ADP.S.2 ADP.W.3 ADP.W.4
;
;**********************************************************************************************
;
;  CURRENT USAGE
;
;     1) SkipGridCheck :
;        Default is turn off, please turn on this option in the switch form if you want to 
;        skip the offgrid check.
;
;     2) HIGH_VOLTAGE:
;	 Default 3.3V is used as high (I/O) voltage.
;	 If other high voltage is used, please DEFINE other variables. 
;        For example,if 2.5V is used as high voltage, then the settings should be:
;		        HIGH_VOLTAGE = 2.5
;        
;	 If 5V is enabled, NT_N rule sections will be disabled.
;
;        CORE_VOLTAGE:
;	 Default 1.8V is used as core voltage.
;	 If lower core voltages are used, please DEFINE another variables. 
;        For example, if 1.5V is used as core voltage, then the settings should be change as:
;
;		         CORE_VOLTAGE = 1.5 
;      
;     3) variable for check SRAM inside layer EXCL:
;
;        By default, we exclude DRC check inside SRAM region covered by exclude layer "EXCL(55)".
;        However, customers could enable this option to check M2 and upward layers inside EXCL
;        in order to check logic rules inside SRAM.
;        Please notice that turn on this option will also disable the waiving function of EXCL. 
;        And the region covered by EXCL will be examined with M2 and upward layers' rules.
;	 Please turn on the line below to enable this function:
; 	        	CHECK_SRAM_EXCL = 1
;
; ATTENTION NOTICE !!!
;============================================================
; Please select proper thickness option of the top metal.
; The default is thick top metal( THICK = 1 ).If using normal
; top metal, please change to THICK = 0.
*/
CHECK_ALRDL = 1; /*  disable when MD&VIAD rules are not checked. */
CHECK_DUMMY_ODPO = 1; /*  disable when Dummy OD&PO are not checked. */
THICK = 1; /*  disable when Normal Top Metal is used. */
Recommend = 0 /*  enable  when Recommended rules are checked. */
HIGH_VOLTAGE = 3.3
/* HIGH_VOLTAGE = 5 */
/* HIGH_VOLTAGE = 2.5 */
CORE_VOLTAGE = 1.8
/* CORE_VOLTAGE = 1.5 */
CHECK_SRAM_EXCL = 0

if((HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chip) 
	"OPTION.HIGH_VOLTAGE.MM  HIGH_VOLTAGE == 5V is not allowed for Mixed_Signal process ")  
) ; 
if(!(HIGH_VOLTAGE == 3.3) then
if(!(HIGH_VOLTAGE == 2.5) then
if(!(HIGH_VOLTAGE == 5) then
 errorLayer( geomCat(chip) 
	"OPTION.HIGH_VOLTAGE  There must be specified an option of HIGH_VOLTAGE ")  
) ; 
) ; 
) ; 
if(!(CORE_VOLTAGE == 1.8) then
if(!(CORE_VOLTAGE == 1.5) then
 errorLayer( geomCat(chip) 
	"OPTION.CORE_VOLTAGE  There must be specified an option of CORE_VOLTAGE ")  
) ; 
) ; 
/*  */
/*  ENVIRONMENT SETUP */
/* ------------------ */
/* DRC INCREMENTAL CONNECT YES */
/*  DRAWN LAYER DEFINITIONS */
/* ------------------------ */
drcExtractRules(

layerDefs( "df2"
	nweli	 = layer(  "NWELL" ) 
	/*  Nwell technology */
	diffi	 = layer(  "DIFF"  type("drawing") ) 
	/*  Active areas */
	dod	 = layer(  "DIFF"  type("dummy") ) 
	/*  Dummy OD (DIFF) */
	odblk	 = layer(  "ODBLK"  type("dummy") ) 
	/*  DOD blocking for insertion */
	pdiffi	 = layer(  "PDIFF" ) 
	/*  Active areas */
	ndiffi	 = layer(  "NDIFF" ) 
	/*  Active areas */
	od2i	 = layer(  "OD2" ) 
	/*  Define thick gate oxides */
	polyi	 = layer(  "POLY1"  type("drawing") ) 
	/*  Polysilicon gates, interconnect */
	dpo	 = layer(  "POLY1"  type("dummy") ) 
	/*  Dummy Poly */
	poblk	 = layer(  "POBLK"  type("dummy") ) 
	/*  DPO blocking for insertion */
	ppi	 = layer(  "PIMP" ) 
	/*  P+ S/D imlant */
	npi	 = layer(  "NIMP" ) 
	/*  N+ S/D imlant */
	bjtdummy	 = layer(  "BJTDUMMY" ) 
	/*  BJT dummy layer */
	diodummy	 = layer(  "DIODUMMY" ) 
	/*  Diode dummy layer */
	coi	 = layer(  "CONT" ) 
	/*  Define connection from M1 to S/D and Gate */
	m1i	 = layer(  "METAL1"  type("drawing") ) 
	/*  First Metal layer */
	via1i	 = layer(  "VIA12" ) 
	/*  Define connection from M2 to M1 */
	m2i	 = layer(  "METAL2"  type("drawing") ) 
	/*  Second Metal layer */
	via2i	 = layer(  "VIA23" ) 
	/*  Define connection from M3 to M2 */
	m3i	 = layer(  "METAL3"  type("drawing") ) 
	/*  Third Metal layer */
	viadi	 = layer(  "VIAD" ) 
	/*  Define connect from MD to Top Metal */
	mdi	 = layer(  "MD"  type("drawing") ) 
	/*  RDL Metal layer above Top Metal */
	cbi	 = layer(  "PAD" ) 
	/*  Passivation opening for Bond Pad */
	cbdi	 = layer(  "CBD" ) 
	/*  Definition of passivation window for bump */
	ubmi	 = layer(  "UBM" ) 
	/*  Bond Pad definition for RDL */
	ppii	 = layer(  "PPI" ) 
	/*  Post Passivation RDL */
	rpoi	 = layer(  "RPO" ) 
	/*  Salicided Block Layer */
	ntni	 = layer(  "NTN" ) 
	/*  Native NMOS blocked implantation */
	plmidei	 = layer(  "PLMIDE" ) 
	/*  Polymide (if drawn) */
	dnwi	 = layer(  "DNW" ) 
	/*  Deep N-WELL */
	vtmpi	 = layer(  "VTM_P" ) 
	/*  Blocking region of PMOS VT implantation */
	vtmni	 = layer(  "VTM_N" ) 
	/*  Blocking region of NMOS VT implantation */
	pv_p	 = layer(  "PV_P" ) 
	/*  PV_P pmos varactor p+ implant layer */
	pv_n	 = layer(  "PV_N" ) 
	/*  PV_N pmos varactor n+ blocking layer */
	hrii	 = layer(  "HRI" ) 
	/*  High Resistor implant */
	m1dmy	 = layer(  "METAL1"  type("dummy") ) 
	/*  Metal1 dummy (if drawn) */
	m2dmy	 = layer(  "METAL2"  type("dummy") ) 
	/*  Metal2 dummy (if drawn) */
	m3dmy	 = layer(  "METAL3"  type("dummy") ) 
	/*  Metal3 dummy (if drawn) */
	mddmy	 = layer(  "MD"  type("dummy") ) 
	/*  MD dummy (if drawn) */
	m1sloti	 = layer(  "METAL1"  type("slot") ) 
	/*  Metal1 slot (if drawn) */
	m2sloti	 = layer(  "METAL2"  type("slot") ) 
	/*  Metal2 slot (if drawn) */
	m3sloti	 = layer(  "METAL3"  type("slot") ) 
	/*  Metal3 slot (if drawn) */
	mdsloti	 = layer(  "MD"  type("slot") ) 
	/*  MD slot (if drawn) */
	ctm2i	 = layer(  "CTM2"  type("drawing") ) 
	/*  Capacitor Top Metal-2 */
	ctm3i	 = layer(  "CTM3"  type("drawing") ) 
	/*  Capacitor Top Metal-3 */
	ctm4i	 = layer(  "CTM4"  type("drawing") ) 
	/*  Capacitor Top Metal-4 */
	ctm5i	 = layer(  "CTM5"  type("drawing") ) 
	/*  Capacitor Top Metal-5 */
	hotwl	 = layer(  "HOTWL" ) 
	/*  Hot N-Well (SEE README HOT_NWEL NOTES) */
	excl	 = layer(  "EXCL" ) 
	/*  Exclude layer */
	drcdmy	 = layer(  "DRCDUMMY" ) 
	/*  DRC I/O waiver */
	rwdmy	 = layer(  "RWDUMMY" ) 
	/*  NWEL Resistor dummy layer */
	dpdmy	 = layer(  "DPDUMMY" ) 
	/*  Dummy Pad area dummy layer */
	pldmy	 = layer(  "PLDUMMY" ) 
	/*  Power Line area dummy layer */
	sdi	 = layer(  "SDI" ) 
	/*  IO ESD region dummy layer */
	esd1dmy	 = layer(  "ESD1DUMMY" ) 
	/*  IO ESD region dummy layer, RPO must enclose whole gate */
	esd2dmy	 = layer(  "ESD2DUMMY" ) 
	/*  IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V */
	esd3dmy	 = layer(  "ESD3DUMMY" ) 
	
	ctmdmy	 = layer(  "CTMDUMMY" ) 
	/*  Cover metal as a capacitor bottom plate */
	rlppdmy	 = layer(  "RLPPDUMMY" ) 
	/*  HRI high Poly resistor dummy layer */
	dmn2v	 = layer(  "DMN2V" ) 
	/*  Dummy layer to avoid N2V in N+ poly resistor */
	dmp2v	 = layer(  "DMP2V" ) 
	/*  Dummy layer to avoid P2V in P+ poly resistor */
	vardmy	 = layer(  "VARDUMMY" ) 
	/*  Dummy layer to cover varactor device */
	pmdmy	 = layer(  "PMDMY" ) 
	/*  Dummy layer to cover fuse window and protection ring structur */
	fwi	 = layer(  "FW" ) 
	/*  Fuse window when x, (x+1) = 3  */
	lmark	 = layer(  "LMARK"  type("drawing") ) 
	/*  L target window for bump process */
	lwi	 = layer(  "LW"  type("drawing") ) 
	/*  L target window for bump process */
	wbdmy	 = layer(  "WBDMY" ) 
	/*  Dummy layer to cover the CUP pad */
	esdi	 = layer(  "ESD" ) 
	/*  For 0.18um 1.8V/5V on i/o esd's implant only. */
	inddmy	 = layer(  "INDDUMMY"  type("drawing") ) 
	/*  Dummy layer to define inductor */
	sealring	 = layer(  "SEALRING" ) 
	/*  SEAL-RING Layer used for SR.S.1 check */
	logo	 = layer(  "LOGO" ) 
	/*  Dummy layer for product labels and LOGO */
	dm1excl	 = layer(  "DMEXCL"  type("dummy1") ) 
	
	dm2excl	 = layer(  "DMEXCL"  type("dummy2") ) 
	
	dm3excl	 = layer(  "DMEXCL"  type("dummy3") ) 
	
	dmdexcl	 = layer(  "DMEXCL"  type("dummyf") ) 
	
	chip = cellBoundary(root)
)
layerDefs( "gds2"
	nweli	 = layer(  2 ) 
	/*  Nwell technology */
	diffi	 = layer(  3 type( 0 ( 2:255 )  ) ) 
	/*  Active areas */
	dod	 = layer( 3 type( 1) ) 
	/*  Dummy OD (DIFF) */
	odblk	 = layer( 150 type( 20) ) 
	/*  DOD blocking for insertion */
	pdiffi	 = layer(  11 ) 
	/*  Active areas */
	ndiffi	 = layer(  12 ) 
	/*  Active areas */
	od2i	 = layer(  4 ) 
	/*  Define thick gate oxides */
	polyi	 = layer(  13 type( 0 ( 2:255 )  ) ) 
	/*  Polysilicon gates, interconnect */
	dpo	 = layer( 13 type( 1) ) 
	/*  Dummy Poly */
	poblk	 = layer( 150 type( 21) ) 
	/*  DPO blocking for insertion */
	ppi	 = layer(  7 ) 
	/*  P+ S/D imlant */
	npi	 = layer(  8 ) 
	/*  N+ S/D imlant */
	bjtdummy	 = layer(  49 ) 
	/*  BJT dummy layer */
	diodummy	 = layer(  56 ) 
	/*  Diode dummy layer */
	coi	 = layer(  15 ) 
	/*  Define connection from M1 to S/D and Gate */
	m1i	 = layer(  16 type( 0 ( 3:255 )  ) ) 
	/*  First Metal layer */
	via1i	 = layer(  17 ) 
	/*  Define connection from M2 to M1 */
	m2i	 = layer(  18 type( 0 ( 3:255 )  ) ) 
	/*  Second Metal layer */
	via2i	 = layer(  27 ) 
	/*  Define connection from M3 to M2 */
	m3i	 = layer(  28 type( 0 ( 3:255 )  ) ) 
	/*  Third Metal layer */
	viadi	 = layer(  167 ) 
	/*  Define connect from MD to Top Metal */
	mdi	 = layer(  168 type( 0 ( 3:255 )  ) ) 
	/*  RDL Metal layer above Top Metal */
	cbi	 = layer(  19 ) 
	/*  Passivation opening for Bond Pad */
	cbdi	 = layer(  169 ) 
	/*  Definition of passivation window for bump */
	ubmi	 = layer(  170 ) 
	/*  Bond Pad definition for RDL */
	ppii	 = layer(  189 ) 
	/*  Post Passivation RDL */
	rpoi	 = layer(  34 ) 
	/*  Salicided Block Layer */
	ntni	 = layer(  129 ) 
	/*  Native NMOS blocked implantation */
	plmidei	 = layer(  89 ) 
	/*  Polymide (if drawn) */
	dnwi	 = layer(  82 ) 
	/*  Deep N-WELL */
	vtmpi	 = layer(  23 ) 
	/*  Blocking region of PMOS VT implantation */
	vtmni	 = layer(  24 ) 
	/*  Blocking region of NMOS VT implantation */
	pv_p	 = layer(  71 ) 
	/*  PV_P pmos varactor p+ implant layer */
	pv_n	 = layer(  72 ) 
	/*  PV_N pmos varactor n+ blocking layer */
	hrii	 = layer(  48 ) 
	/*  High Resistor implant */
	m1dmy	 = layer( 16 type( 1) ) 
	/*  Metal1 dummy (if drawn) */
	m2dmy	 = layer( 18 type( 1) ) 
	/*  Metal2 dummy (if drawn) */
	m3dmy	 = layer( 28 type( 1) ) 
	/*  Metal3 dummy (if drawn) */
	mddmy	 = layer( 168 type( 1) ) 
	/*  MD dummy (if drawn) */
	m1sloti	 = layer( 16 type( 2) ) 
	/*  Metal1 slot (if drawn) */
	m2sloti	 = layer( 18 type( 2) ) 
	/*  Metal2 slot (if drawn) */
	m3sloti	 = layer( 28 type( 2) ) 
	/*  Metal3 slot (if drawn) */
	mdsloti	 = layer( 168 type( 2) ) 
	/*  MD slot (if drawn) */
	ctm2i	 = layer( 67 type( 2) ) 
	/*  Capacitor Top Metal-2 */
	ctm3i	 = layer( 67 type( 3) ) 
	/*  Capacitor Top Metal-3 */
	ctm4i	 = layer( 67 type( 4) ) 
	/*  Capacitor Top Metal-4 */
	ctm5i	 = layer( 67 type( 5) ) 
	/*  Capacitor Top Metal-5 */
	hotwl	 = layer(  51 ) 
	/*  Hot N-Well (SEE README HOT_NWEL NOTES) */
	excl	 = layer(  55 ) 
	/*  Exclude layer */
	drcdmy	 = layer(  60 ) 
	/*  DRC I/O waiver */
	rwdmy	 = layer(  52 ) 
	/*  NWEL Resistor dummy layer */
	dpdmy	 = layer(  65 ) 
	/*  Dummy Pad area dummy layer */
	pldmy	 = layer(  66 ) 
	/*  Power Line area dummy layer */
	sdi	 = layer(  58 ) 
	/*  IO ESD region dummy layer */
	esd1dmy	 = layer(  136 ) 
	/*  IO ESD region dummy layer, RPO must enclose whole gate */
	esd2dmy	 = layer(  137 ) 
	/*  IO ESD region dummy layer, RPO enclose gate 0.05 for 3.3V */
	esd3dmy	 = layer(  234 ) 
	
	ctmdmy	 = layer(  131 ) 
	/*  Cover metal as a capacitor bottom plate */
	rlppdmy	 = layer(  134 ) 
	/*  HRI high Poly resistor dummy layer */
	dmn2v	 = layer(  184 ) 
	/*  Dummy layer to avoid N2V in N+ poly resistor */
	dmp2v	 = layer(  149 ) 
	/*  Dummy layer to avoid P2V in P+ poly resistor */
	vardmy	 = layer(  138 ) 
	/*  Dummy layer to cover varactor device */
	pmdmy	 = layer(  236 ) 
	/*  Dummy layer to cover fuse window and protection ring structur */
	fwi	 = layer(  235 ) 
	/*  Fuse window when x, (x+1) = 3  */
	lmark	 = layer( 63 type( 1) ) 
	/*  L target window for bump process */
	lwi	 = layer( 63 type( 2) ) 
	/*  L target window for bump process */
	wbdmy	 = layer(  183 ) 
	/*  Dummy layer to cover the CUP pad */
	esdi	 = layer(  30 ) 
	/*  For 0.18um 1.8V/5V on i/o esd's implant only. */
	inddmy	 = layer( 139 type( 0) ) 
	/*  Dummy layer to define inductor */
	sealring	 = layer(  126 ) 
	/*  SEAL-RING Layer used for SR.S.1 check */
	logo	 = layer(  178 ) 
	/*  Dummy layer for product labels and LOGO */
	dm1excl	 = layer( 150 type( 1) ) 
	
	dm2excl	 = layer( 150 type( 2) ) 
	
	dm3excl	 = layer( 150 type( 3) ) 
	
	dmdexcl	 = layer( 150 type( 15) ) 
	
	chip = cellBoundary(root)
)

ivIf(!switch("SkipGridCheck") then
offGrid( nweli 0.005 1 "nweli offgrid")
offGrid( diffi 0.005 1 "diffi offgrid")
offGrid( dod 0.005 1 "dod offgrid")
offGrid( odblk 0.005 1 "odblk offgrid")
offGrid( pdiffi 0.005 1 "pdiffi offgrid")
offGrid( ndiffi 0.005 1 "ndiffi offgrid")
offGrid( od2i 0.005 1 "od2i offgrid")
offGrid( polyi 0.005 1 "polyi offgrid")
offGrid( dpo 0.005 1 "dpo offgrid")
offGrid( poblk 0.005 1 "poblk offgrid")
offGrid( ppi 0.005 1 "ppi offgrid")
offGrid( npi 0.005 1 "npi offgrid")
offGrid( bjtdummy 0.005 1 "bjtdummy offgrid")
offGrid( diodummy 0.005 1 "diodummy offgrid")
offGrid( coi 0.005 1 "coi offgrid")
offGrid( m1i 0.005 1 "m1i offgrid")
offGrid( via1i 0.005 1 "via1i offgrid")
offGrid( m2i 0.005 1 "m2i offgrid")
offGrid( via2i 0.005 1 "via2i offgrid")
offGrid( m3i 0.005 1 "m3i offgrid")
offGrid( viadi 0.005 1 "viadi offgrid")
offGrid( mdi 0.005 1 "mdi offgrid")
offGrid( cbi 0.005 1 "cbi offgrid")
offGrid( cbdi 0.005 1 "cbdi offgrid")
offGrid( ubmi 0.005 1 "ubmi offgrid")
offGrid( ppii 0.005 1 "ppii offgrid")
offGrid( rpoi 0.005 1 "rpoi offgrid")
offGrid( ntni 0.005 1 "ntni offgrid")
offGrid( plmidei 0.005 1 "plmidei offgrid")
offGrid( dnwi 0.005 1 "dnwi offgrid")
offGrid( vtmpi 0.005 1 "vtmpi offgrid")
offGrid( vtmni 0.005 1 "vtmni offgrid")
offGrid( pv_p 0.005 1 "pv_p offgrid")
offGrid( pv_n 0.005 1 "pv_n offgrid")
offGrid( hrii 0.005 1 "hrii offgrid")
offGrid( m1dmy 0.005 1 "m1dmy offgrid")
offGrid( m2dmy 0.005 1 "m2dmy offgrid")
offGrid( m3dmy 0.005 1 "m3dmy offgrid")
offGrid( mddmy 0.005 1 "mddmy offgrid")
offGrid( m1sloti 0.005 1 "m1sloti offgrid")
offGrid( m2sloti 0.005 1 "m2sloti offgrid")
offGrid( m3sloti 0.005 1 "m3sloti offgrid")
offGrid( mdsloti 0.005 1 "mdsloti offgrid")
offGrid( ctm2i 0.005 1 "ctm2i offgrid")
offGrid( ctm3i 0.005 1 "ctm3i offgrid")
offGrid( ctm4i 0.005 1 "ctm4i offgrid")
offGrid( ctm5i 0.005 1 "ctm5i offgrid")
offGrid( hotwl 0.005 1 "hotwl offgrid")
offGrid( excl 0.005 1 "excl offgrid")
offGrid( drcdmy 0.005 1 "drcdmy offgrid")
offGrid( rwdmy 0.005 1 "rwdmy offgrid")
offGrid( dpdmy 0.005 1 "dpdmy offgrid")
offGrid( pldmy 0.005 1 "pldmy offgrid")
offGrid( sdi 0.005 1 "sdi offgrid")
offGrid( esd1dmy 0.005 1 "esd1dmy offgrid")
offGrid( esd2dmy 0.005 1 "esd2dmy offgrid")
offGrid( esd3dmy 0.005 1 "esd3dmy offgrid")
offGrid( ctmdmy 0.005 1 "ctmdmy offgrid")
offGrid( rlppdmy 0.005 1 "rlppdmy offgrid")
offGrid( dmn2v 0.005 1 "dmn2v offgrid")
offGrid( dmp2v 0.005 1 "dmp2v offgrid")
offGrid( vardmy 0.005 1 "vardmy offgrid")
offGrid( pmdmy 0.005 1 "pmdmy offgrid")
offGrid( fwi 0.005 1 "fwi offgrid")
offGrid( lmark 0.005 1 "lmark offgrid")
offGrid( lwi 0.005 1 "lwi offgrid")
offGrid( wbdmy 0.005 1 "wbdmy offgrid")
offGrid( esdi 0.005 1 "esdi offgrid")
offGrid( inddmy 0.005 1 "inddmy offgrid")
offGrid( sealring 0.005 1 "sealring offgrid")
offGrid( logo 0.005 1 "logo offgrid")
offGrid( dm1excl 0.005 1 "dm1excl offgrid")
offGrid( dm2excl 0.005 1 "dm2excl offgrid")
offGrid( dm3excl 0.005 1 "dm3excl offgrid")
offGrid( dmdexcl 0.005 1 "dmdexcl offgrid")

)


   procedure( viawithsize( via_size with_size iterations value )
     let( (i)
       for( i 1 iterations
         via_size = geomAnd( geomSize(via_size value) with_size )
       )
       via_size =  via_size
     ) ; ** let **
   ) ; ** procedure viawithsize **

    procedure( geomSizeAndProc( via_size with_size sizeandstep limit )
     let( ()

      limit1 = limit
      via_size_result = via_size
      with_size_init = with_size

      if( (limit1 >= 2 * sizeandstep) then
        via_size = viawithsize( via_size with_size 2 sizeandstep )
        with_size = geomAndNot( with_size via_size )
        via_size_result = geomOr( via_size via_size_result )
        limit1 = limit1 - 2 * sizeandstep

        if( (limit1 >= 3 * sizeandstep) then
          via_size = viawithsize( via_size with_size 3 sizeandstep )
          with_size = geomAndNot( with_size via_size )
          via_size_result = geomOr( via_size via_size_result )
          limit1 = limit1 - 3 * sizeandstep

          if( (limit1 >= 5 * sizeandstep) then
            via_size = viawithsize( via_size with_size 5 sizeandstep )
            with_size = geomAndNot( with_size via_size )
            via_size_result = geomOr( via_size via_size_result )
            limit1 = limit1 - 5 * sizeandstep

            if( (limit1 >= 10 * sizeandstep) then
              via_size = viawithsize( via_size with_size 10 sizeandstep )
              with_size = geomAndNot( with_size via_size )
              via_size_result = geomOr( via_size via_size_result )
              limit1 = limit1 - 10 * sizeandstep

              if( (limit1 >= 20 * sizeandstep) then
                via_size = viawithsize( via_size with_size 20 sizeandstep )
                with_size = geomAndNot( with_size via_size )
                via_size_result = geomOr( via_size via_size_result )
                limit1 = limit1 - 20 * sizeandstep

                if( (limit1 >= 50 * sizeandstep) then
                  via_size = viawithsize( via_size with_size 50 sizeandstep )
                  with_size = geomAndNot( with_size via_size )
                  via_size_result = geomOr( via_size via_size_result )
                  limit1 = limit1 - 50 * sizeandstep
                )
              )
            )
          )
        )
      )

      limitnumber = fix( limit1 / sizeandstep )
      if( (limitnumber > 0) then
        via_size = viawithsize( via_size with_size limitnumber sizeandstep )
        with_size = geomAndNot( with_size via_size )
        via_size_result = geomOr( via_size via_size_result )
      )
      sizeandstep1 = limit1 - limitnumber * sizeandstep
      if( (sizeandstep1 > 0) then
        via_size = viawithsize( via_size with_size 1 sizeandstep1 )
        with_size = geomAndNot( with_size via_size )
        via_size_result = geomOr( via_size via_size_result )
      )

      via_size_result = via_size_result

    )
   ) ; ** procedure newgeomsizeand **

/* LAYER  FUSEi	235	// Fuse window */
/*  Dummy Metal layers */
/* ------------------- */
/*  Metal Slot layers */
/* ------------------ */
/*  Capacitor Top Metal Layers */
/* --------------------------- */
/*  Dummy Layers */
/* ------------- */
 m1i_or1 =  geomOr(m1i m1dmy)  
 m1xd = geomAndNot(m1i_or1 m1sloti)  
 m2i_or1 =  geomOr(m2i m2dmy)  
 m2xd = geomAndNot(m2i_or1 m2sloti)  
 m3i_or1 =  geomOr(m3i m3dmy)  
 m3xd = geomAndNot(m3i_or1 m3sloti)  
 mdi_or1 =  geomOr(mdi mddmy)  
 mdxd = geomAndNot(mdi_or1 mdsloti)  
/* /////////////////////////////////////////////////////////////////////////////// */
/*  EXCLUDE UNCHECKED REGIONS */
/* -------------------------- */
 bulk = geomSize( chip 1.0 noClipAcute )   
if((CHECK_SRAM_EXCL == 1) then
 excl_s = geomAndNot(chip bulk)  /*  Use an empty layer to disable the usage of EXCL */
else;
 excl_s = geomCat(excl)  /*  EXCL_S = EXCL */ 
) ; 
/*  Front-End Layer */
/* ---------------- */
 pweli = geomAndNot(bulk nweli)  
 diffi_or1 =  geomOr(diffi ndiffi)  
 odi = geomOr(diffi_or1 pdiffi)  
 pwel = geomAndNot(pweli excl)  
 nwel = geomAndNot(nweli geomInside(nweli excl ))   
 dnw = geomAndNot(dnwi excl)  
 vtmp = geomAndNot(vtmpi excl)  
 vtmn = geomAndNot(vtmni excl)  
if((CHECK_DUMMY_ODPO == 1) then
 odi_or1 =  geomOr(odi dod)  
 od = geomAndNot(odi_or1 excl)  
 polyi_or1 =  geomOr(polyi dpo)  
 poly = geomAndNot(polyi_or1 excl)  
else;
 od = geomAndNot(odi excl)  
 poly = geomAndNot(polyi excl)  
) ; 
 od2 = geomAndNot(od2i excl)  
 pp = geomAndNot(ppi geomInside(ppi excl ))   
 np = geomAndNot(npi geomInside(npi excl ))   
 co = geomAndNot(coi excl)  
/*  Back-End Layer */
/* --------------- */
 m1 = geomAndNot(m1xd excl)  
 via1 = geomAndNot(via1i excl)  
 m2 = geomAndNot(m2xd geomInside(m2xd excl_s ))   
 via2 = geomAndNot(via2i geomInside(via2i excl_s ))   
 m3 = geomAndNot(m3xd geomInside(m3xd excl_s ))   
 viad = geomAndNot(viadi geomInside(viadi excl_s ))   
 md = geomAndNot(mdxd geomInside(mdxd excl_s ))   
 cb = geomAndNot(cbi excl_s)  
 rpo = geomAndNot(rpoi excl)  
 ntn = geomAndNot(ntni excl)  
/* FUSE	= FUSEi	NOT EXCL */
 fw = geomAndNot(fwi excl_s)  
 lw = geomAndNot(lwi excl_s)  
 hri = geomAndNot(hrii excl)  
 ctm2 = geomAndNot(ctm2i excl_s)  
 ctm3 = geomAndNot(ctm3i excl_s)  
 ctm4 = geomAndNot(ctm4i excl_s)  
 ctm5 = geomAndNot(ctm5i excl_s)  
/*  GLOBAL DERIVED LAYERS FOR RULE CHECKS  */
/* -------------------------------------- */
 nrodi = geomAndNot(odi rpoi)  
 npodi = geomAnd(npi nrodi)  
 ppodi = geomAnd(ppi nrodi)  
 nonwri = geomAndNot(nweli geomButtOrOver(nweli rwdmy ))  /*  NWEL - NWR(OD) - NWR(STI) */ 
 ntapi = geomAnd(npodi nonwri)  /*  NWEL Pick-Up */
 nacti = geomAndNot(npodi nweli)  /*  NMOS Device */
 ptapi = geomAndNot(ppodi nweli)  /*  Substrate(PWEL) Pick-Up */
 pacti = geomAnd(ppodi nonwri)  /*  PMOS Device  */
 psdi = geomAndNot(pacti polyi)  /*  PMOS source/drain,separated */
 nsdi = geomAndNot(nacti polyi)  /*  NMOS source/drain,separated   */
 ilp1i = geomAndNot(polyi rpoi)  /*  Interconnection poly */
 npod = geomAnd(np od)  /*  N+ OD region */
 ppod = geomAnd(pp od)  /*  P+ OD region */
 rnwel = geomButtOrOver( nwel rwdmy  )  /*  NWEL resistor (UNDER OD & STI) */ 
 nonwr = geomAndNot(nwel rnwel)  /*  NWEL - NWR(OD) - NWR(STI) */
 ntap = geomAnd(npod nonwr)  /*  NWEL Pick-Up */
 nact = geomAndNot(npod nwel)  /*  NMOS Device */
 ptap = geomAndNot(ppod nwel)  /*  Substrate(PWEL) Pick-Up */
 pact = geomAnd(ppod nwel)  /*  PMOS Device */
 dact = geomOr(nact pact)  /*  NMOS and PMOS Device */
 dstp = geomOr(ntap ptap)  /*  NWEL and PWEL Pick-Up */
 imp = geomOr(pp np)  /*  N+ and P+ implant  */
 all_gate = geomAnd(poly od)  /*  Gate regions for NMOS and PMOS */
 poly_iso = geomAndNot(poly od)  /*  Interconnect POLY */
 lvgt = geomAndNot(all_gate od2)  /*  1.8V gate */
 gate_w = geomGetEdge(poly inside od)  /*  Gate width */ 
 gate_np = geomAnd(all_gate np)  /*  N+ Gate */
 gate_pp = geomAnd(all_gate pp)  /*  P+ Gate */
 fpo1 = geomCat(poly_iso)  /*  Field poly */ 
 rpo_not_sdi = geomAndNot(rpo sdi)  
 pores = geomAnd(fpo1 rpo_not_sdi)  /*  POLY resistor region */
 ilp1 = geomAndNot(poly_iso rpo)  /*  Interconnection poly */
 dmp2v_or1 =  geomOr(dmp2v dmn2v)  /*  High resistance poly resistor dummy layer for DRC */
 hrdmy = geomOr(dmp2v_or1 rlppdmy)  /*  High resistance poly resistor dummy layer for DRC */
 hrep = geomAnd(pores hrdmy)  /*  High precision and resistacne poly resistor */
 hvn_gox = geomAnd(npod od2)  /*  Device n-type diffusion for thick gate NMOS */
 hvp_gox = geomAnd(ppod od2)  /*  Device p-type diffusion for thick gate PMOS */
 hv_ngate_w = geomGetEdge(gate_w inside hvn_gox)  /*  3.3V NMOS gate edges */ 
 hv_pgate_w = geomGetEdge(gate_w inside hvp_gox)  /*  3.3V PMOS gate edges */ 
 butt_ptap = geomButtOnly(geomOutside(ptap nact) nact )  /*  PWEL Tap butting n-type active diffusion */ 
 act_od = geomButtOrOver( od poly  )   
 pnsd = geomAndNot(act_od all_gate)  
 co_diff = geomOutside( co poly_iso  )  /*  Diffusion contacts + floating contacts */ 
 asd1 = geomEnclose( pnsd co_diff  )   
 co_poly = geomAndNot(co geomOutside(co poly_iso ))  /*  POLY contacts */ 
/*  For checks such as PP.C.4/C.5, NP.C.4/C.5. */
 gate_np_sz1 =  geomSize( gate_np 0.03 noClipAcute )   
 gate_np_sz1_and1 =  geomAnd(gate_np_sz1 poly)  
 exgate_np = geomSize( gate_np_sz1_and1 0.32 noClipAcute )   
 gate_pp_sz1 =  geomSize( gate_pp 0.03 noClipAcute )   
 gate_pp_sz1_and1 =  geomAnd(gate_pp_sz1 poly)  
 exgate_pp = geomSize( gate_pp_sz1_and1 0.32 noClipAcute )   
 cb_or1 =  geomOr(cb fw)  
 fuse_lmark = geomOr(cb_or1 lw)  
 rngx = geomAndNot(pmdmy fuse_lmark)  
/*  BUILD CONNECTION FOR RULE CHECKS  */
/* --------------------------------- */
 viat = geomAndNot(via2i geomButtOrOver(via2i ctm2i ))   
 viac = geomAnd(via2i ctm2i)  
geomConnect(
	buttOrOver(ntapi nweli)
	buttOrOver(ntapi psdi)
	buttOrOver(ptapi nsdi)
	via(coi m1xd ilp1i ntapi ptapi psdi nsdi)
	via(via1i m1xd m2xd)
	via(viat m2xd m3xd)
	via(viac ctm2i m3xd)
	via(viadi m3xd mdxd)
)
/*  NWEL CHECKS */
/* ============= */
 nwel_and1 =  geomAnd(nwel hotwl)  
 hot_nwel = geomOr(nwel_and1 rnwel)  
 drc( nwel   width < 0.86  withCornerTouch 
	"NW.W.1  Min. NWEL width < 0.86 ")  
 drc( hot_nwel   width < 2.10  withCornerTouch 
	"NW.W.2  Min. HOT_NWEL width < 2.10 ")  
nws1_nwel_nodal = geomCat( nwel )
geomStamp(nws1_nwel_nodal nweli)  
 drc( nws1_nwel_nodal   sep < 1.40  diffNet shielded 
	"NW.S.1  Min. different potential NWEL space < 1.40 ")  
 drc( rnwel nwel  sep < 1.40  withIntersection withSingularPoint 
	"NW.S.1 2  Min. different potential NWEL space < 1.40 ")  
 drc( rnwel   sepNotch < 1.40  
	"NW.S.1 3  Min. different potential NWEL space < 1.40 ")  
 drc( nwel   sepNotch < 0.60  
	"NW.S.2  Min. same potential NWEL space < 0.6 ")  
/*  NWEL (within OD) RESISTOR CHECKS */
/* ==================================== */
 nwres = geomButtOrOver( rnwel rpo  )  /*  NWEL resistor (UNDER OD) */ 
 odwr = geomButtOrOver( od nwres  )  /*  OD area of NW resistor */ 
 npwr = geomButtOrOver( np nwres  )  /*  N+ implant on NW resistor terminals */ 
 cowr = geomButtOrOver( co_diff nwres  )  /*  Contact on NW resistor terminals */ 
 rhwr = geomAndNot(odwr rpo)  /*  Non-Salicided area of NW resistor */
 drc( odwr nwres  enc < 1.0  shielded withIntersection withSingularPoint 
	"NWR.E.1  Min. OD enclose NWEL resistor < 1.0 ")  
 errorLayer( geomStraddle( nwres odwr  ) 
	"NWR.E.1 2  Min. OD enclose NWEL resistor < 1.0 ")  
 drc( nwres cowr  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.E.2  Min. NWEL resistor enclose CO < 0.3 ")  
 errorLayer( geomStraddle( cowr nwres  ) 
	"NWR.E.2 2  Min. NWEL resistor enclose CO < 0.3 ")  
 drc( rhwr nwres  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.C.1  Min. RPO hole enclose NWEL < 0.3 ")  
 drc( rpo odwr  enc < 0.22  shielded withIntersection withSingularPoint 
	"NWR.C.2  Min. RPO enclose OD (with NWEL resistor) < 0.22 ")  
 drc( rhwr cowr  enc < 0.3  shielded withIntersection withSingularPoint 
	"NWR.C.3  Min. RPO hole enclose NWEL resistor CO < 0.3 ")  
 errorLayer( geomStraddle( cowr rhwr  ) 
	"NWR.C.3 2  Min. RPO hole enclose NWEL resistor CO < 0.3 ")  
 drc( npwr rpo  ovlp < 0.4  shielded withIntersection withSingularPoint 
	"NWR.O.1  Min. RPO overlap NP < 0.4 ")  
 nwro1_x = geomButtOrOver( rpo nwres  )   
nwro1_x_out1 = geomHoles( nwro1_x innermost )
 nwro11_h = nwro1_x_out1  
 errorLayer( geomAndNot(nwro11_h npwr) 
	"NWR.O.1 2  Min. RPO overlap NP < 0.4 ") 
 errorLayer( geomAnd(rwdmy npod) 
	"NWR.R.1  NW resistor doped by implants not allowed. ") 
 errorLayer( geomAnd(rwdmy ppod) 
	"NWR.R.1 2  NW resistor doped by implants not allowed. ") 
/* NWEL under STI */
 nwres_sti = geomAndNot(rnwel geomButtOrOver(rnwel rpo ))  /*  NWEL resistor (UNDER STI) */ 
 odwr_sti = geomButtOrOver( od nwres_sti  )   
 npwr_sti = geomButtOrOver( np nwres_sti  )   
 drc( npwr_sti odwr_sti  enc < 0.18  shielded withIntersection withSingularPoint 
	"NWR.E.3  Min. extension of NP to OD (NWEL resistor under STI) 0.18 um ")  
 errorLayer( geomAndNot(odwr_sti npwr_sti) 
	"NWR.E.3 2  Min. extension of NP to OD (NWEL resistor under STI) 0.18 um ") 
if(!(HIGH_VOLTAGE == 5) then
/*  NT_N */
/* ====== */
 ntn_od = geomAndNot(od geomOutside(od ntn ))   
 ntn_po = geomAnd(poly ntn)  
 ntn_gate_w = geomGetEdge(ntn_po inside ntn_od)   
 ntn_po_w = geomGetEdge(ntn_po coincident poly)   
 errorLayer( geomEnclose( ntn od keep > 1 ) 
	"NT_N.I.2  only one OD region allowed to be put in an NT_N region ")  
 errorLayer( geomAnd(ntn gate_pp) 
	"NT_N.I.3  A P+GATE is not allowed to be put in an NT_N region ") 
 ntn_po_w_ang01 = geomGetAngledEdge(ntn_po_w keep == 0)
 ntn_po_w_ang011 = geomGetAdjacentEdge(ntn_po_w ntn_po_w_ang01 )
 ntn_po_w_ang451 = geomGetAngledEdge(ntn_po_w keep == 45)
 errorLayer( geomAndNot(ntn_po_w_ang011 ntn_po_w_ang451) 
	"NT_N.I.4  A bent poly region is not allowed to put in an NT_N region ") 
 ntn_po_w_ang02 = geomGetAngledEdge(ntn_po_w keep == 0)
 ntn_po_w_ang021 = geomGetAdjacentEdge(ntn_po_w ntn_po_w_ang02 )
 ntn_po_w_ang901 = geomGetAngledEdge(ntn_po_w keep == 90)
 errorLayer( geomAndNot(ntn_po_w_ang021 ntn_po_w_ang901) 
	"NT_N.I.4 3  A bent poly region is not allowed to put in an NT_N region ") 
 drc( ntn   width < 0.74  withCornerTouch 
	"NT_N.W.1  Minimum width of a NT_N region < 0.74 ")  
if((CORE_VOLTAGE == 1.8) then
 drc( ntn_gate_w   width < 0.5  
	"NT_N.W.2  Minimum poly gate dimension of a 1.8V blocked NT_N device < 0.5 ")  
) ; 
if((CORE_VOLTAGE == 1.5) then
 drc( ntn_gate_w   width < 0.37  
	"NT_N.W.2.LV  Minimum poly gate dimension of a 1.5V blocked NT_N device < 0.37 ")  
) ; 
 nt_nw2b_z = geomGetEdge(ntn_gate_w inside od2)   
 drc( nt_nw2b_z   width < 1.2  
	"NT_N.W.2B  Minimum poly gate dimension of a 3.3V blocked NT_N device < 1.2 ")  
 nt_ne1_a = geomButtOrOver( ntn npod  )   
 nt_ne11_b = geomButtOrOver( npod ntn  )   
 nt_ne12_c = geomSize( nt_ne11_b 0.26 noClipAcute )   
 nt_ne13_d = geomSize( nt_ne1_a -0.26 noClipAcute )   
 errorLayer( geomXor(nt_ne1_a nt_ne12_c) 
	"NT_N.E.1  Maximum and Minimum extension from NT_N region beyond an NP OD region 0.26 ") 
 errorLayer( geomXor(nt_ne11_b nt_ne13_d) 
	"NT_N.E.1 2  Maximum and Minimum extension from NT_N region beyond an NP OD region 0.26 ") 
 drc( ntn   sepNotch < 0.86  
	"NT_N.S.1  Minimum space between two NT_N regions < 0.86 ")  
if((CORE_VOLTAGE == 1.5) then
if((HIGH_VOLTAGE == 3.3) then
 drc( od2 ntn  enc < 0.86  shielded withIntersection withSingularPoint 
	"NT_N.E.2.LV  OD2 enclose 3.3V NTN < 0.86um ")  
 errorLayer( geomStraddle( ntn od2  ) 
	"NT_N.E.2.LV 2  OD2 enclose 3.3V NTN < 0.86um ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( od2 ntn  enc < 0.86  shielded withIntersection withSingularPoint 
	"NT_N.E.2.LV 3  OD2 enclose 2.5V NTN < 0.86um ")  
 errorLayer( geomStraddle( ntn od2  ) 
	"NT_N.E.2.LV 4  OD2 enclose 2.5V NTN < 0.86um ")  
) ; 
) ; 
 drc( od ntn  sep < 0.52  shielded withIntersection withSingularPoint 
	"NT_N.C.1  MInimum clearance from NT_N to OD < 0.52 ")  
 errorLayer( geomStraddle( od ntn  ) 
	"NT_N.C.1 2  MInimum clearance from NT_N to OD < 0.52 ")  
 drc( ntn nwel  sep < 1.66  shielded withIntersection withSingularPoint 
	"NT_N.C.2  Minimum clearance frome a NT_N region to NWEL edge < 1.66 ")  
 errorLayer( geomAnd(ntn nwel) 
	"NT_N.C.2 2  Minimum clearance frome a NT_N region to NWEL edge < 1.66 ") 
if((CORE_VOLTAGE == 1.5) then
 drc( ntn od2  sep < 0.86  shielded withIntersection withSingularPoint 
	"NT_N.C.3.LV  OD2 space to 1.5V NTN < 0.86um ")  
) ; 
 drc( poly ntn_od  enc < 0.35  shielded withIntersection withSingularPoint 
	"NT_N.PO.1  Minimum overlap of a PO region extended into field oxide(endcap) < 0.35 ")  
) ; /* #IFNDEF or IFDEF 5V */
/*  OD CHECKS */
/* ============== */
 drc( od   width < 0.22  withCornerTouch 
	"OD.W.1_OD.W.2  Min. OD width for MOS and interconnect < 0.22 ")  
 drc( od   sepNotch < 0.28  
	"OD.S.1  Min. OD space < 0.28 ")  
 drc( nonwr npod  enc < 0.12  shielded withIntersection withSingularPoint 
	"OD.C.1  Min. NWEL olap NPOD tie down < 0.12 ")  
 errorLayer( geomStraddle( npod nonwr  ) 
	"OD.C.1 2  Min. NWEL olap NPOD tie down < 0.12 ")  
 odc2_odc3_a = geomAndNot(npod geomInside(npod nwel ))   
 odc2_odc31_x = geomAndNot(odc2_odc3_a odwr)  
 drc( odc2_odc31_x nwel  sep < 0.43  shielded withIntersection withSingularPoint 
	"OD.C.2_OD.C.3  Min. NWEL to NPOD space < 0.43 ")  
 errorLayer( geomStraddle( odc2_odc31_x nwel  ) 
	"OD.C.2_OD.C.3 2  Min. NWEL to NPOD space < 0.43 ")  
 drc( nwel ppod  enc < 0.43  shielded withIntersection withSingularPoint 
	"OD.C.4  NWEL overlap PPOD < 0.43 ")  
 errorLayer( geomStraddle( ppod nwel  ) 
	"OD.C.4 2  NWEL overlap PPOD < 0.43 ")  
 drc( ptap nwel  sep < 0.12  shielded withIntersection withSingularPoint 
	"OD.C.5  NWEL space PPOD outside NW < 0.12 ")  
/*  OD.C.6 is checked by PP.C.4 and NP.C.4 */
/*  OD.S.2 is not necessary to check */
 dact_iact1 =  geomButtOrOver( dact all_gate  )   
 odw3_sd = geomAndNot(dact_iact1 all_gate)  
 odw31_np_pp_bte = geomGetEdge(npod butting ppod)   
 odw32_butted_edge = geomGetLength( odw31_np_pp_bte  keep < 0.42 )   
 odw32_butted_edge1 = geomSize(odw32_butted_edge 0.005 edges)
 odw33_check_sd = geomButtOrCoin( odw3_sd odw32_butted_edge1 )   
 check_sd_coin1 =  geomGetEdge(odw33_check_sd coincident od)   
 odw34_narrow_sd = drc( check_sd_coin1   width < 0.42  opposite )
 odw32_butted_edge2 = geomSize(odw32_butted_edge 0.005 edges)
 narrow_sd_with1 =  geomButtOrCoin( odw34_narrow_sd odw32_butted_edge2 )   
 gate_w_sz1 = geomSize(gate_w 0.005 edges)
 narrow_sd_with2 =  geomButtOrCoin( odw34_narrow_sd gate_w_sz1 )   
 odw35_check_od = geomOr(narrow_sd_with1 narrow_sd_with2)  
 od_coin1 =  geomGetEdge(od coincident odw35_check_od)   
 errorLayer( geomGetLength(od_coin1  keep > 0.8 contiguous ) 
	"OD.W.3  Length of active with width < 0.42, connected to butted strap > 0.8 ")  
 drc( od  area < 0.202 
	"OD.A.1  Min. area of stand-alone OD region < 0.202 ") 
/*  OD2 CHECKS */
/* =============== */
 dactg = geomOr(dact all_gate)  
 od2e1_check_edge = drc( od2 dactg  enc < 0.32  shielded withIntersection withSingularPoint edgeb )
 errorLayer( geomAndNot(od2e1_check_edge geomGetEdge(od2e1_check_edge butting dstp)) 
	"OD2.E.1  Min. OD2 olap OD < 0.32 ")  
 errorLayer( geomInside( od2 dactg  ) 
	"OD2.E.1 2  Min. OD2 olap OD < 0.32 ") /*  OD2 totally inside OD */ 
if(!(HIGH_VOLTAGE == 5) then
if((CORE_VOLTAGE == 1.8) then
/*  Merge if space < 0.45 um */
 drc( od2   sepNotch < 0.45  
	"OD2.S.1 2  Min. OD2 space < 0.45 ")  
) ; 
) ; 
if((CORE_VOLTAGE == 1.5) then
/*  Merge if space < 0.86 um */
 drc( od2   sepNotch < 0.86  
	"OD2.S.1.LV 2  Min. OD2 space < 0.86 ")  
) ; 
 drc( od2 dactg  sep < 0.32  shielded withIntersection withSingularPoint 
	"OD2.C.1  Min. OD2 space to OD < 0.32 ")  
 od2c2_a = geomGetEdge(od2 inside dact)   
 drc( gate_w od2c2_a  sep < 0.40  shielded withIntersection 
	"OD2.C.2  Min. OD2 space to gate < 0.40 ")  
 od2e2_a = geomGetEdge(od2 inside dact)   
 drc( od2e2_a gate_w  enc < 0.40  shielded withIntersection 
	"OD2.E.2  Min. enclosure of gate by OD2 < 0.40 ")  
 errorLayer( geomStraddle( all_gate od2  ) 
	"OD2.E.2 2  Min. enclosure of gate by OD2 < 0.40 ")  
if((CORE_VOLTAGE == 1.5) then
 drc( od2 nwel 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.E.4.LV  OD2 enclose NWEL >= 0.86um/Align if less than 0.86um ")  
 drc( nwel od2 0 < sep < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LV  OD2 to NWEL >= 0.86um/Align if less than 0.86um ")  
 drc( nwel od2 0 < enc < 0.86  shielded withIntersection withSingularPoint 
	"OD2.C.4.LV 2  OD2 to NWEL >= 0.86um/Align if less than 0.86um ")  
 drc( nwel od2 0 < ovlp < 0.86  withIntersection withSingularPoint 
	"OD2.O.1.LV OD2 overlaps NWEL >= 0.86um ")  
) ; 
/*  POLY checks */
/* ============= */
/* PO.W.1A is checked by PO.W.3 */
/* PO.W.2A is checked by PO.W.3 */
 drc( poly   width < 0.18  withCornerTouch 
	"PO.W.3  Min. POLY width for interconnect, 1.8V NMOS, 1.8V PMOS < 0.18 ")  
if((HIGH_VOLTAGE == 3.3) then
 drc( hv_pgate_w   width < 0.30  
	"PO.W.1B  Min. POLY gate length 3.3V pmos < 0.30 ")  
 drc( hv_ngate_w   width < 0.35  
	"PO.W.2B  Min. POLY gate length 3.3v nmos < 0.35 ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( hv_pgate_w   width < 0.26  
	"PO.W.1B 2  Min. POLY gate length 2.5V pmos < 0.26 ")  
 drc( hv_ngate_w   width < 0.26  
	"PO.W.2B 2  Min. POLY gate length 2.5v nmos < 0.26 ")  
) ; 
if((HIGH_VOLTAGE == 5) then
 drc( hv_pgate_w   width < 0.5  
	"PO.W.1B 3  Min. POLY gate length 5.0V pmos < 0.5 ")  
 drc( hv_ngate_w   width < 0.6  
	"PO.W.2B 3  Min. POLY gate length 5.0v nmos < 0.6 ")  
) ; 
 pos1_y = geomGetEdge(all_gate butting asd1)   
 drc( pos1_y  0 <  sepNotch < 0.375  
	"PO.S.1  Min. POLY space on OD with contact < 0.375 ")  
 drc( poly   sepNotch < 0.25  
	"PO.S.2_PO.S.3  Min. POLY space: on OD w/o contact and interconnect < 0.25 ")  
 drc( poly od  sep < 0.1  shielded withIntersection withSingularPoint 
	"PO.C.1  Min. POLY on field space to active < 0.1 ")  
 drc( od poly  enc < 0.32  shielded withIntersection withSingularPoint 
	"PO.C.2  Min. OD overhang gate < 0.32 ")  
 drc( poly od  enc < 0.22  shielded withIntersection withSingularPoint 
	"PO.O.1  Min. POLY overhang active < 0.22 ")  
unselected_por1a_581 = 1; /* UNSELECT CHECK PO.R.1A */
unselected_por1a_582 = 1; /* UNSELECT CHECK PO.R.1A */
unselected_por1a_583 = 1; /* UNSELECT CHECK PO.R.1A */
 lvgt_ang1 = geomGetAngledEdge( lvgt keep == 45 )
 drc( lvgt_ang1   width < 0.21  opposite 
	"PO.R.1B  45 degree 1.8V gate min. length < 0.21 ")  
 por2_long_po = drc( ilp1  area > 0.18* 50 ) 
 por21_check_po = geomButtOrOver( por2_long_po co  )   
 por22_check_co = geomButtOrOver( co por21_check_po  )   
por23_co_a = geomSizeAndProc( por22_check_co por21_check_po 0.25 50/2 )  
 por24_po_a = geomButtOrOver( por21_check_po por23_co_a keep == 1 )   
 por25_po_b = geomButtOrOver( por21_check_po por23_co_a keep > 1 )   
 por26_co_b = geomButtOrOver( por23_co_a por24_po_a  )   
por27_co_c = geomSizeAndProc( por26_co_b por24_po_a 0.25 50/2 )  
 po_a_not1 =  geomAndNot(por24_po_a por27_co_c)  
 po_b_not1 =  geomAndNot(por25_po_b por23_co_a)  
 por28_bad = geomOr(po_a_not1 po_b_not1)  
 por29_bad_edge = geomGetEdge(por28_bad coincident poly)   
 por210_error = drc( por29_bad_edge   width <= 0.24  )
 errorLayer( geomButtOrOver( por21_check_po por210_error  ) 
	"PO.R.2  Max. POLY length between contacts when PO width less than 0.24um > 50.00 ")  
/*  PP CHECKS */
/* ============ */
 ppe4_nwelc = geomSize( nweli 0.43 noClipAcute )   
 ppe4_nwels = geomSize( ppe4_nwelc 0.18 noClipAcute )   
 ppe4_od = geomAnd(ptap ppe4_nwels)  
 ppe4_c1 = drc( pp ppe4_od 0 < enc < 0.18  opposite shielded withIntersection )
 ppe4_c2 = drc( pp ppe4_od 0 < enc < 0.18 corner shielded withIntersection )
 ppe4_c3 = drc( pp ppe4_od 0 < enc < 0.18  shielded  app == 0 withIntersection )
 ppe4_c2_sz1 =  geomSize( ppe4_c2 0.005 noClipAcute )   
 ppe4_c4 = geomAndNot(ppe4_c2_sz1 ppe4_od)  
 ppe4_c1_or1 =  geomOr(ppe4_c1 ppe4_c3)  
 ppe4_all = geomOr(ppe4_c1_or1 ppe4_c4)  
 ppe4_checkod = geomGetEdge(ppe4_all butting ppe4_od)   
 npc3_c1 = drc( ppe4_od np 0 < sep < 0.18  opposite shielded withIntersection )
 npc3_c2 = drc( ppe4_od np 0 < sep < 0.18 corner shielded withIntersection )
 npc3_c3 = drc( ppe4_od np 0 < sep < 0.18  shielded  app == 0 withIntersection )
 npc3_c2_sz1 =  geomSize( npc3_c2 0.005 noClipAcute )   
 npc3_c4 = geomAndNot(npc3_c2_sz1 ppe4_od)  
 npc3_c1_or1 =  geomOr(npc3_c1 npc3_c3)  
 npc3_all = geomOr(npc3_c1_or1 npc3_c4)  
 npc3_checkod = geomGetEdge(npc3_all butting ppe4_od)   
 npe4_nwelc = geomSize( nweli -0.43 noClipAcute )   
 npe4_nwels = geomSize( npe4_nwelc -0.18 noClipAcute )   
 npe4_od = geomAndNot(ntap npe4_nwels)  
 npe4_c1 = drc( np npe4_od 0 < enc < 0.18  opposite shielded withIntersection )
 npe4_c2 = drc( np npe4_od 0 < enc < 0.18 corner shielded withIntersection )
 npe4_c3 = drc( np npe4_od 0 < enc < 0.18  shielded  app == 0 withIntersection )
 npe4_c2_sz1 =  geomSize( npe4_c2 0.005 noClipAcute )   
 npe4_c4 = geomAndNot(npe4_c2_sz1 npe4_od)  
 npe4_c1_or1 =  geomOr(npe4_c1 npe4_c3)  
 npe4_all = geomOr(npe4_c1_or1 npe4_c4)  
 npe4_checkod = geomGetEdge(npe4_all butting npe4_od)   
 ppc3_c1 = drc( npe4_od pp 0 < sep < 0.18  opposite shielded withIntersection )
 ppc3_c2 = drc( npe4_od pp 0 < sep < 0.18 corner shielded withIntersection )
 ppc3_c3 = drc( npe4_od pp 0 < sep < 0.18  shielded  app == 0 withIntersection )
 ppc3_c2_sz1 =  geomSize( ppc3_c2 0.005 noClipAcute )   
 ppc3_c4 = geomAndNot(ppc3_c2_sz1 npe4_od)  
 ppc3_c1_or1 =  geomOr(ppc3_c1 ppc3_c3)  
 ppc3_all = geomOr(ppc3_c1_or1 ppc3_c4)  
 ppc3_checkod = geomGetEdge(ppc3_all butting npe4_od)   
 drc( pp   width < 0.440  withCornerTouch 
	"PP.W.1  PP width < 0.440 ")  
 drc( pp   sepNotch < 0.440  
	"PP.S.1  PP space < 0.440 ")  
/*  N active in pwell can be butting or non-butting.  */
/*  The non-butting N active is not allowed to touch PP. */
 drc( pp nact 0 < sep < 0.260  shielded withIntersection withSingularPoint 
	"PP.C.1 3  PP space to n active in pwell < 0.260 ")  
 ppc1_x = drc( pp nact  sep < 0.001  shielded withIntersection edgeb )
 ppc11_y = geomSize(ppc1_x 0.001 edges)   
 errorLayer( geomAndNot(ppc11_y geomButtOrOver(ppc11_y ppod )) 
	"PP.C.1 4  PP space to n active in pwell < 0.260 ")  
 drc( pp ntap 0 < sep < 0.1  shielded withIntersection withSingularPoint 
	"PP.C.2  PP space to non-butting NTAP < 0.1 with PWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(ppc3_checkod outside npe4_nwelc) 
	"PP.C.3  PP space to non-butting NTAP < 0.18 with PWEL space < 0.43 ")  
/*  PP.C.4 is checked by NP.C.5 and PP.R.1 */
/*  This rule must extend out of gate in the direction of PO by 0.35um */
 errorLayer( geomAndNot(exgate_pp pp) 
	"PP.C.5 2  PP extension over (P gate) + (field poly within 0.35um) < 0.32um ") 
 drc( od pp 0 < ovlp < 0.230  shielded withIntersection withSingularPoint 
	"PP.O.1  PP extends into p active < 0.230 ")  
 drc( pp pact 0 < enc < 0.180  shielded withIntersection withSingularPoint 
	"PP.E.1  PP olap OD < 0.180 ")  
 ppe1_y = drc( pp pact  enc < 0.001  shielded withIntersection edgeb )
 ppe11_z = geomSize(ppe1_y 0.001 edges)   
 errorLayer( geomAndNot(ppe11_z geomButtOrOver(ppe11_z npod )) 
	"PP.E.1 2  PP olap OD < 0.180 ")  
 errorLayer( geomGetEdge(imp coincident od) 
	"PP.E.1_NP.E.1  Implant can not coincident OD edge except butted diffusion ")  
 drc( pp ptap 0 < enc < 0.02  shielded withIntersection withSingularPoint 
	"PP.E.3  Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 ")  
 ppe3_x = drc( pp ptap  enc < 0.001  shielded withIntersection edgeb )
 ppe31_y = geomSize(ppe3_x 0.001 edges)   
 errorLayer( geomAndNot(ppe31_y geomButtOrOver(ppe31_y npod )) 
	"PP.E.3 2  Minimum enclosure of PTAP by PP < 0.02 with NWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(ppe4_checkod inside ppe4_nwelc) 
	"PP.E.4  Min. enc. of PTAP by PP < 0.18 with NWEL space < 0.43 ")  
/*  PP.C.6 is not necessary to check */
/*  PP.E.5 is not necessary to check */
 drc( pp  area < 0.3844 
	"PP.A.1  Minimum area of PP < 0.3844 ") 
unselected_ppe6_688 = 1; /* UNSELECT CHECK PP.E.6 */
unselected_ppe6_689 = 1; /* UNSELECT CHECK PP.E.6 */
unselected_ppe6_690 = 1; /* UNSELECT CHECK PP.E.6 */
 errorLayer( geomAnd(pp np) 
	"PP.R.1_NP.R.1  PP and NP not allowed to overlap ") 
/*  PP.R.2 is not necessary to check */
 od_iact1 =  geomButtOrOver( od polyi  )   
 od_iact1_not1 =  geomAndNot(od_iact1 odwr)  
 errorLayer( geomAndNot(od_iact1_not1 imp) 
	"PP.R.3_NP.R.3  OD must be fully covered by PP and NP ,except OD without interacting CO OR PO ") 
 od_iact2 =  geomButtOrOver( od coi  )   
 od_iact2_not1 =  geomAndNot(od_iact2 odwr)  
 errorLayer( geomAndNot(od_iact2_not1 imp) 
	"PP.R.3_NP.R.3 2  OD must be fully covered by PP and NP ,except OD without interacting CO OR PO ") 
/*  NP CHECKS */
/* ============ */
 drc( np   width < 0.440  withCornerTouch 
	"NP.W.1  NP width < 0.440 ")  
 drc( np   sepNotch < 0.440  
	"NP.S.1  NP space < 0.440 ")  
/*  P active in NWEL can be butting or non-butting. */
/*  The non-butting P active is not allowed to touch NP. */
 drc( np pact 0 < sep < 0.260  shielded withIntersection withSingularPoint 
	"NP.C.1 3  NP space to p active in NWEL < 0.260 ")  
 npc1_x = drc( np pact  sep < 0.001  shielded withIntersection edgeb )
 npc11_y = geomSize(npc1_x 0.001 edges)   
 errorLayer( geomAndNot(npc11_y geomButtOrOver(npc11_y npod )) 
	"NP.C.1 4  NP space to p active in NWEL < 0.260 ")  
 drc( np ptap 0 < sep < 0.1  shielded withIntersection withSingularPoint 
	"NP.C.2  NP space to non-butting ptap < 0.1 with NWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(npc3_checkod inside ppe4_nwelc) 
	"NP.C.3  NP space to non-butting ptap < 0.18 with NWEL space < 0.43 ")  
/*  NP.C.4 is checked by PP.C.5 and NP.R.1 */
/*  This rule must extend out of gate in the direction of PO by 0.35um */
 errorLayer( geomAndNot(exgate_np np) 
	"NP.C.5 2  NP extension over (N gate) + (field poly within 0.35um) < 0.32um ") 
 drc( od np 0 < ovlp < 0.230  shielded withIntersection withSingularPoint 
	"NP.O.1  NP extends into n active < 0.230 ")  
 npe1_x = geomAndNot(nact odwr)  
 drc( np npe1_x 0 < enc < 0.180  shielded withIntersection withSingularPoint 
	"NP.E.1  NP olap OD < 0.180 ")  
 npe11_y = drc( np npe1_x  enc < 0.001  shielded withIntersection edgeb )
 npe12_z = geomSize(npe11_y 0.001 edges)   
 errorLayer( geomAndNot(npe12_z geomButtOrOver(npe12_z ppod )) 
	"NP.E.1 2  NP olap OD < 0.180 ")  
 drc( np ntap 0 < enc < 0.02  shielded withIntersection withSingularPoint 
	"NP.E.3  Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43 ")  
 npe3_x = drc( np ntap  enc < 0.001  shielded withIntersection edgeb )
 npe31_y = geomSize(npe3_x 0.001 edges)   
 errorLayer( geomAndNot(npe31_y geomButtOrOver(npe31_y ppod )) 
	"NP.E.3 2  Minimum enclosure of NTAP by NP < 0.02 with PWEL space >= 0.43 ")  
 errorLayer( geomGetEdge(npe4_checkod outside npe4_nwelc) 
	"NP.E.4  Min. enc. of NTAP by NP < 0.18 with PWEL space < 0.43 ")  
/*  NP.C.6 is not necessary to check */
/*  NP.E.5 is not necessary to check */
 drc( np  area < 0.3844 
	"NP.A.1  Minimum area of NP < 0.3844 ") 
 drc( np pores  enc < 0.18  shielded withIntersection withSingularPoint 
	"NP.E.6  Min enc of POLY resistor by NP < 0.18 ")  
/*  NP.R.2 is not necessary to check */
/*  RPO checks */
/* =========== */
cb_out1 = geomHoles(cb)
 cb_hole = cb_out1  
 cb_sr = geomButtOnly(geomOutside(cb cb_hole) cb_hole keep == 1)   
 rpo_not_sr = geomAndNot(rpo geomButtOrOver(rpo cb_sr ))   
 drc( rpo   width < 0.43  withCornerTouch 
	"RPO.W.1  Minimum RPO width < 0.43 ")  
 drc( rpo   sepNotch < 0.43  
	"RPO.S.1  Minimum RPO space < 0.43 ")  
 drc( rpo od  sep < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.1  Minimum RPO space to OD < 0.22 ")  
 drc( rpo co  sep < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.2  Minimum RPO space to CO < 0.22 ")  
 errorLayer( geomAnd(co rpo) 
	"RPO.C.2 2  Minimum RPO space to CO < 0.22 ") 
 all_gate_not1 =  geomAndNot(all_gate drcdmy)  
 all_gate_not11 =  geomAndNot(all_gate_not1 esd1dmy)  
 all_gate_not111 =  geomAndNot(all_gate_not11 esd2dmy)  
 rpoc3_a = geomAndNot(all_gate_not111 esd3dmy)  
 drc( rpo rpoc3_a  sep < 0.45  shielded withIntersection withSingularPoint 
	"RPO.C.3  Minimum RPO space to gate < 0.45 ")  
 errorLayer( geomAnd(rpo rpoc3_a) 
	"RPO.C.3 2  Minimum RPO space to gate < 0.45 ") 
 drc( rpo od  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.4  Minimum RPO overhang OD < 0.22 ")  
 errorLayer( geomInside( rpo_not_sr od  ) 
	"RPO.C.4 2  Minimum RPO overhang OD < 0.22 ")  
 drc( od rpo  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.E.1  Minimum OD overhang RPO < 0.22 ")  
 drc( rpo poly  enc < 0.22  shielded withIntersection withSingularPoint 
	"RPO.C.5  Minimum RPO overhang POLY < 0.22 ")  
 errorLayer( geomInside( rpo_not_sr poly  ) 
	"RPO.C.5 2  Minimum RPO overhang POLY < 0.22 ")  
 drc( rpo poly_iso  sep < 0.30  shielded withIntersection withSingularPoint 
	"RPO.C.6  Minimum clearance RPO to unrelated poly < 0.3um ")  
 drc( rpo  area < 2 
	"RPO.A.1  RPO min. area < 2 um*um ") 
/*  CO checks */
/* =============== */
 errorLayer( geomAndNot( co geomGetRectangle( co length == 0.22 width == 0.22 swap ) )
	"CO.W.1  contact width != 0.22 ")  
 drc( co   sepNotch < 0.25  
	"CO.S.1  contact spacing < 0.25 ")  
 cos2_a = geomSize( geomSize( co ( 0.30/2 )  noClipAcute ) -( 0.30/2 )  noClipAcute )  /*  space < 0.3um treat as array */ 
 cos21_b = geomSize( geomSize( cos2_a -0.7 noClipAcute ) 0.7 noClipAcute )  /*  (0.22*3+0.3*2) = 1.26  (3 COs Mix.) */ 
 cos22_c = geomButtOrOver( cos21_b co keep >= 16 )  /*  1.63-0.22 = 1.41       (Max. CO shift space)  */ 
 cos23_d = geomButtOrOver( co cos22_c  )  /*  so 1.26 < CONTY width < 1.41 */ 
 drc( cos23_d  0 <  sepNotch < 0.28  
	"CO.S.2  Min space between two contacts in larger than 4x4 array. ") /*  & we use CONTY width = 1.4 */ 
 drc( co_diff all_gate  sep < 0.16  shielded withIntersection withSingularPoint 
	"CO.C.1_CO.R.1  diff contact to gate space < 0.16, or contact on gate ")  
 errorLayer( geomAnd(co_diff all_gate) 
	"CO.C.1_CO.R.1 2  diff contact to gate space < 0.16, or contact on gate ") 
 drc( co_poly od  sep < 0.20  shielded withIntersection withSingularPoint 
	"CO.C.2  poly contact space to OD < 0.20 ")  
 drc( od co_diff  enc < 0.10  shielded withIntersection withSingularPoint 
	"CO.E.1  active olap contact < 0.10, also floating contacts ")  
 errorLayer( geomGetEdge(co_diff outside od) 
	"CO.E.1 2  active olap contact < 0.10, also floating contacts ")  
 drc( poly_iso co_poly  enc < 0.10  shielded withIntersection withSingularPoint 
	"CO.E.2  poly olap contact < 0.10 ")  
 errorLayer( geomStraddle( co_poly poly_iso  ) 
	"CO.E.2 2  poly olap contact < 0.10 ")  
 drc( pp co_diff  enc < 0.12  shielded withIntersection withSingularPoint 
	"CO.E.3  implant olap contact < 0.12 ")  
 errorLayer( geomGetEdge(pp inside co_diff) 
	"CO.E.3 2  implant olap contact < 0.12 ")  
 drc( np co_diff  enc < 0.12  shielded withIntersection withSingularPoint 
	"CO.E.4  implant olap contact < 0.12 ")  
 errorLayer( geomGetEdge(np inside co_diff) 
	"CO.E.4 2  implant olap contact < 0.12 ")  
/*  CO.R.2 is checked by CO.E.3/CO.E.4 */
/*  CO.R.3 is checked by RPO.C.2 */
/*  M1 checks */
/* ============= */
 drc( m1   width < 0.23  withCornerTouch 
	"M1.W.1  Min. M1 width < 0.23 ")  
 drc( m1   sepNotch < 0.23  
	"M1.S.1  Min. M1 space < 0.23 ")  
m1s2_m1_s5 = geomGrow( m1 -5 -5 -5 -5 )
m1s21_m1_g5 = geomGrow( m1s2_m1_s5 5 5 5 5 )
 m1s22_m1_wide = geomAnd(m1s21_m1_g5 m1)  
m1s23_m1_exp = geomSizeAndProc( m1s22_m1_wide m1 0.161 1 )  
 m1s24_m1_branch = geomAndNot(m1s23_m1_exp m1s22_m1_wide)  
 m1s25_m1_branch_edge = geomGetEdge(m1s24_m1_branch coincident m1)   
 m1_exp_sz1 =  geomSize( m1s23_m1_exp 0.6 noClipAcute )   
 m1s26_m1_check = geomAnd(m1 m1_exp_sz1)  
 m1s27_m1_branch_check0 = geomSize(m1s25_m1_branch_edge 0.6 edges)   
 m1s28_m1_branch_check1 = geomSize(m1s25_m1_branch_edge 0.005 edges)   
 m1s29_m1_branch_check2 = drc( m1s28_m1_branch_check1   sepNotch < 0.005  )
 m1s210_m1_branch_check3 = geomSize( m1s29_m1_branch_check2 (0.6-0.005 ) noClipAcute )   
 m1_branch_check01 =  geomOr(m1s27_m1_branch_check0 m1s210_m1_branch_check3)  
 m1s211_m1_branch_check = geomAnd(m1 m1_branch_check01)  
m1s212_m1_widec = geomCat( m1s22_m1_wide )
geomStamp(m1s212_m1_widec m1xd)  
m1s213_m1_checkc = geomCat( m1s26_m1_check )
geomStamp(m1s213_m1_checkc m1xd)  
m1s214_m1_branchc = geomCat( m1s24_m1_branch )
geomStamp(m1s214_m1_branchc m1xd)  
m1s215_m1_branch_checkc = geomCat( m1s211_m1_branch_check )
geomStamp(m1s215_m1_branch_checkc m1xd)  
 drc( m1s212_m1_widec m1s213_m1_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M1.S.2  Min. space to wide M1 (>10um) < 0.6 ")  
 drc( m1s214_m1_branchc m1s215_m1_branch_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M1.S.2 2  Min. space to wide M1 (>10um) < 0.6 ")  
 drc( m1 co  enc < 0.005  shielded withIntersection withSingularPoint 
	"M1.E.1  Min. extension of a M1 region beyond a CO region < 0.005 ")  
 errorLayer( geomAndNot(co m1) 
	"M1.E.1 2  Min. extension of a M1 region beyond a CO region < 0.005 ") 
 m1e2_x = drc( m1 co  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 m1e2_x_ang01 = geomGetAngledEdge(m1e2_x keep == 0)
 m1e2_x_ang011 = geomGetAdjacentEdge(m1e2_x m1e2_x_ang01 )
 m1e2_x_ang451 = geomGetAngledEdge(m1e2_x keep == 45)
 errorLayer( geomAndNot(m1e2_x_ang011 m1e2_x_ang451) 
	"M1.E.2  Min. extension of M1 end-of-line region beyond CO region < 0.06 ") /*  adjacent narrow sides */
 drc( m1  area < 0.202 
	"M1.A.1  Min. M1 area < 0.202 ") 
/*  Density check M1.R.1 included at the end of this file */
/*  VIA1 checks */
/* ============= */
 via1w1_a = geomAndNot( via1 geomGetRectangle( via1 length == 0.26 width == 0.26 swap ) )  
 errorLayer( geomOutside( via1w1_a rngx  ) 
	"VIA1.W.1  VIA1 must be 0.26 x 0.26 ") /*  exclude from metal fuse protection ring area */ 
 drc( via1   sepNotch < 0.26  
	"VIA1.S.1  Min. VIA1 space < 0.26 ")  
 drc( m1 via1  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA1.E.1  Min. extension of a M1 region beyond a VIA1 region < 0.01 ")  
 errorLayer( geomAndNot(via1 m1) 
	"VIA1.E.1 2  Min. extension of a M1 region beyond a VIA1 region < 0.01 ") 
 via1e2_x = drc( m1 via1  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via1e2_x_ang01 = geomGetAngledEdge(via1e2_x keep == 0)
 via1e2_x_ang011 = geomGetAdjacentEdge(via1e2_x via1e2_x_ang01 )
 via1e2_x_ang451 = geomGetAngledEdge(via1e2_x keep == 45)
 errorLayer( geomAndNot(via1e2_x_ang011 via1e2_x_ang451) 
	"VIA1.E.2  Min. extension of M1 end-of-line region beyond VIA1 region < 0.06 ") /*  adjacent narrow sides */
/*  VIA1.C.1 is not necessary to check */
/*  M2 checks */
/* ============= */
 drc( m2   width < 0.28  withCornerTouch 
	"M2.W.1  Min. M2 width < 0.28 ")  
 drc( m2   sepNotch < 0.28  
	"M2.S.1  Min. M2 space < 0.28 ")  
m2s2_m2_s5 = geomGrow( m2 -5 -5 -5 -5 )
m2s21_m2_g5 = geomGrow( m2s2_m2_s5 5 5 5 5 )
 m2s22_m2_wide = geomAnd(m2s21_m2_g5 m2)  
m2s23_m2_exp = geomSizeAndProc( m2s22_m2_wide m2 0.196 1 )  
 m2s24_m2_branch = geomAndNot(m2s23_m2_exp m2s22_m2_wide)  
 m2s25_m2_branch_edge = geomGetEdge(m2s24_m2_branch coincident m2)   
 m2_exp_sz1 =  geomSize( m2s23_m2_exp 0.6 noClipAcute )   
 m2s26_m2_check = geomAnd(m2 m2_exp_sz1)  
 m2s27_m2_branch_check0 = geomSize(m2s25_m2_branch_edge 0.6 edges)   
 m2s28_m2_branch_check1 = geomSize(m2s25_m2_branch_edge 0.005 edges)   
 m2s29_m2_branch_check2 = drc( m2s28_m2_branch_check1   sepNotch < 0.005  )
 m2s210_m2_branch_check3 = geomSize( m2s29_m2_branch_check2 (0.6-0.005 ) noClipAcute )   
 m2_branch_check01 =  geomOr(m2s27_m2_branch_check0 m2s210_m2_branch_check3)  
 m2s211_m2_branch_check = geomAnd(m2 m2_branch_check01)  
m2s212_m2_widec = geomCat( m2s22_m2_wide )
geomStamp(m2s212_m2_widec m2xd)  
m2s213_m2_checkc = geomCat( m2s26_m2_check )
geomStamp(m2s213_m2_checkc m2xd)  
m2s214_m2_branchc = geomCat( m2s24_m2_branch )
geomStamp(m2s214_m2_branchc m2xd)  
m2s215_m2_branch_checkc = geomCat( m2s211_m2_branch_check )
geomStamp(m2s215_m2_branch_checkc m2xd)  
 drc( m2s212_m2_widec m2s213_m2_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M2.S.2  Min. space to wide M2 (>10um) < 0.6 ")  
 drc( m2s214_m2_branchc m2s215_m2_branch_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M2.S.2 2  Min. space to wide M2 (>10um) < 0.6 ")  
 drc( m2 via1  enc < 0.01  shielded withIntersection withSingularPoint 
	"M2.E.1  Min. extension of a M2 region beyond a VIA1 region < 0.01 ")  
 errorLayer( geomAndNot(via1 m2) 
	"M2.E.1 2  Min. extension of a M2 region beyond a VIA1 region < 0.01 ") 
 m2e2_x = drc( m2 via1  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 m2e2_x_ang01 = geomGetAngledEdge(m2e2_x keep == 0)
 m2e2_x_ang011 = geomGetAdjacentEdge(m2e2_x m2e2_x_ang01 )
 m2e2_x_ang451 = geomGetAngledEdge(m2e2_x keep == 45)
 errorLayer( geomAndNot(m2e2_x_ang011 m2e2_x_ang451) 
	"M2.E.2  Min. extension of M2 end-of-line region beyond VIA1 region < 0.06 ") /*  adjacent narrow sides */
 drc( m2  area < 0.202 
	"M2.A.1  Min M2 area region < 0.202 ") 
/*  Density check M2.R.1 included at the end of this file */
 cb_cup = geomButtOrOver( cb wbdmy  )   
/*  VIA2 checks */
/* ============= */
 via2r = geomOutside( via2 cb_cup  )   
 via2w1_a = geomAndNot( via2r geomGetRectangle( via2r length == 0.36 width == 0.36 swap ) )  
 errorLayer( geomOutside( via2w1_a rngx  ) 
	"VIA2.W.1  VIA2 must be 0.36 x 0.36 ") /*  exclude from metal fuse protection ring area */ 
 drc( via2r   sepNotch < 0.35  
	"VIA2.S.1  Min. VIA2 spacing < 0.35 ")  
 drc( m2 via2r  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIA2.E.1  Min. extension of a M2 region beyond a VIA2 region < 0.01 ")  
 errorLayer( geomAndNot(via2r m2) 
	"VIA2.E.1 2  Min. extension of a M2 region beyond a VIA2 region < 0.01 ") 
 via2e2_x = drc( m2 via2r  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 via2e2_x_ang01 = geomGetAngledEdge(via2e2_x keep == 0)
 via2e2_x_ang011 = geomGetAdjacentEdge(via2e2_x via2e2_x_ang01 )
 via2e2_x_ang451 = geomGetAngledEdge(via2e2_x keep == 45)
 errorLayer( geomAndNot(via2e2_x_ang011 via2e2_x_ang451) 
	"VIA2.E.2  Min. extension of a M2 end-of-line region beyond VIA2 region < 0.06 ") /*  adjacent narrow sides */
/*  VIA2.C.1 is not necessary to check */
if((CHECK_ALRDL == 1) then
/*  VIAD checks */
/* ============= */
 viadr = geomOutside( viad cb_cup  )   
 viadw1_a = geomAndNot( viadr geomGetRectangle( viadr length == 0.36 width == 0.36 swap ) )  
 errorLayer( geomOutside( viadw1_a rngx  ) 
	"VIAD.W.1  VIAD must be 0.36 x 0.36 ") /*  exclude from metal fuse protection ring area */ 
 drc( viadr   sepNotch < 0.35  
	"VIAD.S.1  Min. VIAD spacing < 0.35 ")  
 drc( m3 viadr  enc < 0.01  shielded withIntersection withSingularPoint 
	"VIAD.E.1  Min. extension of a M3 region beyond a VIAD region < 0.01 ")  
 errorLayer( geomAndNot(viadr m3) 
	"VIAD.E.1 2  Min. extension of a M3 region beyond a VIAD region < 0.01 ") 
 viade2_x = drc( m3 viadr  enc < 0.06  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 viade2_x_ang01 = geomGetAngledEdge(viade2_x keep == 0)
 viade2_x_ang011 = geomGetAdjacentEdge(viade2_x viade2_x_ang01 )
 viade2_x_ang451 = geomGetAngledEdge(viade2_x keep == 45)
 errorLayer( geomAndNot(viade2_x_ang011 viade2_x_ang451) 
	"VIAD.E.2  Min. extension of a M3 end-of-line region beyond VIAD region < 0.06 ") /*  adjacent narrow sides */
/*  VIAD.C.1 is not necessary to check */
) ; 
if((THICK == 0) then
/*  M3 checks */
/* ============= */
 drc( m3   width < 0.44  withCornerTouch 
	"M3.W.1  Min. M3 width < 0.44 ")  
 drc( m3   sepNotch < 0.46  
	"M3.S.1  Min. M3 space < 0.46 ")  
m3s2_m3_s5 = geomGrow( m3 -5 -5 -5 -5 )
m3s21_m3_g5 = geomGrow( m3s2_m3_s5 5 5 5 5 )
 m3s22_m3_wide = geomAnd(m3s21_m3_g5 m3)  
m3s23_m3_exp = geomSizeAndProc( m3s22_m3_wide m3 0.322 1 )  
 m3s24_m3_branch = geomAndNot(m3s23_m3_exp m3s22_m3_wide)  
 m3s25_m3_branch_edge = geomGetEdge(m3s24_m3_branch coincident m3)   
 m3_exp_sz1 =  geomSize( m3s23_m3_exp 0.6 noClipAcute )   
 m3s26_m3_check = geomAnd(m3 m3_exp_sz1)  
 m3s27_m3_branch_check0 = geomSize(m3s25_m3_branch_edge 0.6 edges)   
 m3s28_m3_branch_check1 = geomSize(m3s25_m3_branch_edge 0.005 edges)   
 m3s29_m3_branch_check2 = drc( m3s28_m3_branch_check1   sepNotch < 0.005  )
 m3s210_m3_branch_check3 = geomSize( m3s29_m3_branch_check2 (0.6-0.005 ) noClipAcute )   
 m3_branch_check01 =  geomOr(m3s27_m3_branch_check0 m3s210_m3_branch_check3)  
 m3s211_m3_branch_check = geomAnd(m3 m3_branch_check01)  
m3s212_m3_widec = geomCat( m3s22_m3_wide )
geomStamp(m3s212_m3_widec m3xd)  
m3s213_m3_checkc = geomCat( m3s26_m3_check )
geomStamp(m3s213_m3_checkc m3xd)  
m3s214_m3_branchc = geomCat( m3s24_m3_branch )
geomStamp(m3s214_m3_branchc m3xd)  
m3s215_m3_branch_checkc = geomCat( m3s211_m3_branch_check )
geomStamp(m3s215_m3_branch_checkc m3xd)  
 drc( m3s212_m3_widec m3s213_m3_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M3.S.2  Min. space to wide M3 (>10um) < 0.6 ")  
 drc( m3s214_m3_branchc m3s215_m3_branch_checkc 0 < sep < 0.6  diffNet withIntersection 
	"M3.S.2 2  Min. space to wide M3 (>10um) < 0.6 ")  
 drc( m3 via2  enc < 0.09  shielded withIntersection withSingularPoint 
	"M3.E.1  Min. extension of a M3 region beyond a VIA2 region < 0.09 ")  
 errorLayer( geomAndNot(via2 m3) 
	"M3.E.1 2  Min. extension of a M3 region beyond a VIA2 region < 0.09 ") 
 drc( m3  area < 0.562 
	"M3.A.1  Min. M3 area region < 0.562 ") 
if((CHECK_ALRDL == 1) then
/*  MD checks */
/* ============= */
 drc( md   width < 0.44  withCornerTouch 
	"MD.W.1  Min. MD width < 0.44 ")  
 drc( md   sepNotch < 0.46  
	"MD.S.1  Min. MD space < 0.46 ")  
mds2_md_s5 = geomGrow( md -5 -5 -5 -5 )
mds21_md_g5 = geomGrow( mds2_md_s5 5 5 5 5 )
 mds22_md_wide = geomAnd(mds21_md_g5 md)  
mds23_md_exp = geomSizeAndProc( mds22_md_wide md 0.322 1 )  
 mds24_md_branch = geomAndNot(mds23_md_exp mds22_md_wide)  
 mds25_md_branch_edge = geomGetEdge(mds24_md_branch coincident md)   
 md_exp_sz1 =  geomSize( mds23_md_exp 0.6 noClipAcute )   
 mds26_md_check = geomAnd(md md_exp_sz1)  
 mds27_md_branch_check0 = geomSize(mds25_md_branch_edge 0.6 edges)   
 mds28_md_branch_check1 = geomSize(mds25_md_branch_edge 0.005 edges)   
 mds29_md_branch_check2 = drc( mds28_md_branch_check1   sepNotch < 0.005  )
 mds210_md_branch_check3 = geomSize( mds29_md_branch_check2 (0.6-0.005 ) noClipAcute )   
 md_branch_check01 =  geomOr(mds27_md_branch_check0 mds210_md_branch_check3)  
 mds211_md_branch_check = geomAnd(md md_branch_check01)  
mds212_md_widec = geomCat( mds22_md_wide )
geomStamp(mds212_md_widec mdxd)  
mds213_md_checkc = geomCat( mds26_md_check )
geomStamp(mds213_md_checkc mdxd)  
mds214_md_branchc = geomCat( mds24_md_branch )
geomStamp(mds214_md_branchc mdxd)  
mds215_md_branch_checkc = geomCat( mds211_md_branch_check )
geomStamp(mds215_md_branch_checkc mdxd)  
 drc( mds212_md_widec mds213_md_checkc 0 < sep < 0.6  diffNet withIntersection 
	"MD.S.2  Min. space to wide MD (>10um) < 0.6 ")  
 drc( mds214_md_branchc mds215_md_branch_checkc 0 < sep < 0.6  diffNet withIntersection 
	"MD.S.2 2  Min. space to wide MD (>10um) < 0.6 ")  
 drc( md viad  enc < 0.09  shielded withIntersection withSingularPoint 
	"MD.E.1  Min. extension of a MD region beyond a VIAD region < 0.09 ")  
 errorLayer( geomAndNot(viad md) 
	"MD.E.1 2  Min. extension of a MD region beyond a VIAD region < 0.09 ") 
 drc( md  area < 0.562 
	"MD.A.1  Min. MD area region < 0.562 ") 
) ; 
) ; 
/*  METAL RATIO CHECKS */
/* ====================== */
 por3_all_poly = geomOr(polyi dpo)  
 por3_all_poly1 = drc(por3_all_poly 0 <=  coverage < 0.14 )
 errorLayer( geomGetCoverage( por3_all_poly1  0 <=  keep < 0.14  ) 
	"PO.R.3  Min poly area coverage < 14% ") 

 m1xd_den1 = drc(m1xd 0 <=  coverage < 0.3 )
 errorLayer( geomGetCoverage( m1xd_den1  0 <=  keep < 0.3  ) 
	"M1.R.1  Min M1 area coverage < 30% ") 

 m2xd_den1 = drc(m2xd 0 <=  coverage < 0.3 )
 errorLayer( geomGetCoverage( m2xd_den1  0 <=  keep < 0.3  ) 
	"M2.R.1  Min M2 area coverage < 30% ") 

if((THICK == 0) then
 m3xd_den1 = drc(m3xd 0 <=  coverage < 0.3 )
 errorLayer( geomGetCoverage( m3xd_den1  0 <=  keep < 0.3  ) 
	"M3.R.1  Min M# area coverage < 30% ") 

) ; 
 mdxd_den1 = drc(mdxd 0 < coverage < 0.3 )
 errorLayer( geomGetCoverage( mdxd_den1  0 < keep < 0.3  ) 
	"MD.R.1  Min MD area coverage < 30% ") 

/*  Dummy Pad */
/* ========== */
 dp_v1 = geomAnd(dpdmy via1)  
 dp_v2 = geomAnd(dpdmy via2)  
 dp_vd = geomAnd(dpdmy viad)  
 errorLayer( geomAndNot(dpdmy m1) 
	"ADP.R.0A  chip corner dummy pad structure should be M1/M2.../M3 ") 
 errorLayer( geomAndNot(dpdmy m2) 
	"ADP.R.0A 2  chip corner dummy pad structure should be M1/M2.../M3 ") 
 errorLayer( geomAndNot(dpdmy m3) 
	"ADP.R.0A 3  chip corner dummy pad structure should be M1/M2.../M3 ") 
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via1 )) 
	"ADP.R.0B  chip corner dummy pad structure should be VIA1/VIA2.../VIA3 ")  
 errorLayer( geomAndNot(dpdmy geomEnclose(dpdmy via2 )) 
	"ADP.R.0B 2  chip corner dummy pad structure should be VIA1/VIA2.../VIA3 ")  
 adpr0c_grp1 = geomCat(dp_v2)   
 adpr0c1_grp2 = geomOr(dp_v1 dp_vd)  
 errorLayer( geomAnd(adpr0c_grp1 adpr0c1_grp2) 
	"ADP.R.0C  Via structure in Dummy Pad ") 
 drc( dp_v1   sepNotch < 0.58  
	"ADP.S.1_VIA1  Via1 spacing (the same level) < 0.58um. ")  
 drc( dp_v2   sepNotch < 0.58  
	"ADP.S.1_VIA2  Via2 spacing (the same level) < 0.58um. ")  
 drc( dp_vd   sepNotch < 0.58  
	"ADP.S.1_VIAD  ViaD spacing (the same level) < 0.58um. ")  
 drc( dp_v1 dp_v2  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_V1_V2  Via1 and Via2 spacing < 0.16um. ")  
 drc( dp_v2 dp_vd  sep < 0.16  shielded withIntersection withSingularPoint 
	"ADP.C.2_V2_VD  Via2 and ViaD spacing < 0.16um. ")  
 drc( m1 dp_v1  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V1_M1  Metal1 enclose Via1 in dummy pad < 3um. ")  
 drc( m2 dp_v1  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V1_M2  Metal2 enclose Via1 in dummy pad < 3um. ")  
 drc( m2 dp_v2  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V2_M2  Metal2 enclose Via2 in dummy pad < 3um. ")  
 drc( m3 dp_v2  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_V2_M3  Metal3 enclose Via2 in dummy pad < 3um. ")  
 drc( m3 dp_vd  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_VD_M3  Meta3l enclose ViaD in dummy pad < 3um. ")  
 drc( md dp_vd  enc < 3  shielded withIntersection withSingularPoint 
	"ADP.E.1_VD_MD  MD enclose ViaD in dummy pad < 3um. ")  
/*  ADP.W.1 is checked by VIAx.W.1 ( x= 1..1) */
/*  ADP.W.2 is checked by VIA2.W.1 */
/*  Guideline */
 drc( dpdmy   sepNotch < 2  
	"ADP.S.2  dummy pad spacing < 2um. ")  
 adpw3_dpadg = drc( dpdmy  0 < width <= 80  opposite )
 errorLayer( geomAndNot(dpdmy adpw3_dpadg) 
	"ADP.W.3  dummy pad width > 80um ") 
 drc( dpdmy  0 < width < 40  
	"ADP.W.4  dummy pad width < 40um ")  
/*  Power Line */
/* =========== */
 pl_v1 = geomAnd(pldmy via1)  
 pl_v2 = geomAnd(pldmy via2)  
 pl_vd = geomAnd(pldmy viad)  
 adpr0d_grp1 = geomCat(pl_v2)   
 adpr0d1_grp2 = geomOr(pl_v1 pl_vd)  
 errorLayer( geomAnd(adpr0d_grp1 adpr0d1_grp2) 
	"ADP.R.0D  Via structure in Power Line ") 
 drc( pl_v1   sepNotch < 0.58  
	"ADP.S.4_V1  Via1 spacing (the same level) < 0.58um. ")  
 drc( pl_v2   sepNotch < 0.58  
	"ADP.S.4_V2  Via2 spacing (the same level) < 0.58um. ")  
 drc( pl_vd   sepNotch < 0.58  
	"ADP.S.4_VD  ViaD spacing (the same level) < 0.58um. ")  
 drc( pl_v1 pl_v2  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.3_V1_V2  Vias spacing (different level) in chip corner power line < 0.23um. ")  
 drc( pl_v2 pl_vd  sep < 0.23  shielded withIntersection withSingularPoint 
	"ADP.C.3_V2_VD  Vias spacing (different level) in chip corner power line < 0.23um. ")  
 drc( m1 pl_v1  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V1_M1  Metal1 enclose Via1 in chip corner power line < 0.2um. ")  
 drc( m2 pl_v1  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V1_M2  Metal2 enclose Via1 in chip corner power line < 0.2um. ")  
 drc( m2 pl_v2  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V2_M2  Metal2 enclose Via2 in chip corner power line < 0.2um. ")  
 drc( m3 pl_v2  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_V2_M3  Metal3 enclose Via2 in chip corner power line < 0.2um. ")  
 drc( m3 pl_vd  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_VD_M3  Metal3 enclose ViaD in chip corner power line < 0.2um. ")  
 drc( md pl_vd  enc < 0.2  shielded withIntersection withSingularPoint 
	"ADP.E.2_VD_MD  MD enclose ViaD in chip corner power line < 0.2um. ")  
/* METAL SLOT CHECKS */
/* ================ */
/* Bonding pad ,chip corner dummy pad ,and inductor need not put slot */
 cb_non_cup = geomAndNot(cbi geomButtOrOver(cbi wbdmy ))   
 slt_exd = geomOr(cb_non_cup dpdmy)  
 slt_exdt = geomOr(cbi dpdmy)  
 pad_exd = geomAndNot(ubmi geomButtOrOver(ubmi mdxd ))   
 m1exd = geomAndNot(m1xd slt_exd)  
/* M1 SLOT CHECKS */
/* ============== */
m1exd_out1 = geomHoles( m1exd innermost )
 m1innerhole = m1exd_out1  
 m1bighole = geomSize( m1innerhole -5 noClipAcute )   
 m1hole = geomOutside( m1innerhole m1bighole  )   
 m1holespace = geomAndNot(m1hole m1exd)  
 fim1c = geomOr(m1exd m1holespace)  
 fim1c_sz1 =  geomSize( geomSize( fim1c -1.0 noClipAcute ) 1.0 noClipAcute )   
 fim1c_sz1_sz1 =  geomSize( geomSize( fim1c_sz1 -17.5 ) 17.5 )   
 lm1xa = geomAnd(fim1c_sz1_sz1 fim1c)  
 lm1x = geomEncloseRect( lm1xa 35.005 35.005 )   
 m1holed = geomAnd(m1holespace lm1x)  
 m1exd_sz1 =  geomSize( geomSize( m1exd -1.0 noClipAcute ) 1.0 noClipAcute )   
 m1exd_sz1_sz1 =  geomSize( geomSize( m1exd_sz1 -17.5 ) 17.5 )   
 ams1m1_a = geomAnd(m1exd_sz1_sz1 m1exd)  
 errorLayer( geomEncloseRect( ams1m1_a 35.005 35.005 ) 
	"AMS.1.M1  Wide Metal (>35um) must have slot. ")  
geomConnect(
	buttOrOver(m1holed lm1x)
)
processAntenna(
	gate((lm1x m1holed))
        antenna( m1holed )
        ratio = m1holed.area/lm1x.area
      drcAntenna( m1holed lm1x ratio keep < 0.015  
	"AMS.DN.M1  Min. Hole density for metal lines that need to apply slot  1.5% ")
)
m1exd_out2 = geomHoles( m1exd innermostEmpty )
 m1hoc = m1exd_out2  
 m1hod = geomSize( geomSize( m1hoc -5 ) 5 )  /*  Assume Metal Slot < 10um */ 
 m1ho = geomOutside( m1hoc m1hod  )  /*  Metal slot (include not in wide metal) */ 
 fim1 = geomOr(m1exd m1ho)  /*  Metal with slot fill in */
 fim1_sz1 =  geomSize( geomSize( fim1 -17.5 noClipAcute ) 17.5 noClipAcute )   
 m1wma1 = geomAnd(fim1_sz1 fim1)  
 m1wma = geomEncloseRect( m1wma1 35.005 35.005 )   
 m1wm = geomAndNot(m1wma geomOutside(m1wma m1ho ))   
 m1slt = geomInside( m1ho m1wm  )   
m1wmd = geomAnd(m1wma m1exd)  
 m1wme = geomButtOnly(geomOutside(m1wmd m1slt) m1slt )   
 s_fim1 = geomAndNot(m1xd m1wme) 
 s_fim1e = geomGetEdge( s_fim1 butting m1wme ) /* check edge */
 g_fim1e = geomGetLength( s_fim1e keep >= 10 contiguous ) /* good edge */
 g_fim1eg = geomSize( g_fim1e 0.005 edges unmergedOut )
 m1wmeg = geomSize( m1wme 0.005 edges unmergedOut )
 b_fim1e = geomButtOrOver( m1wmeg s_fim1 )   
 errorLayer( geomAndNot( b_fim1e geomButtOrOver( b_fim1e g_fim1eg )) 
	"AM.W.1.M1  Min. width for metal connected to wide metal 10um. ")

 m2exd = geomAndNot(m2xd slt_exdt)  
/* M2 SLOT CHECKS */
/* ============== */
m2exd_out1 = geomHoles( m2exd innermost )
 m2innerhole = m2exd_out1  
 m2bighole = geomSize( m2innerhole -5 noClipAcute )   
 m2hole = geomOutside( m2innerhole m2bighole  )   
 m2holespace = geomAndNot(m2hole m2exd)  
 fim2c = geomOr(m2exd m2holespace)  
 fim2c_sz1 =  geomSize( geomSize( fim2c -1.0 noClipAcute ) 1.0 noClipAcute )   
 fim2c_sz1_sz1 =  geomSize( geomSize( fim2c_sz1 -17.5 ) 17.5 )   
 lm2xa = geomAnd(fim2c_sz1_sz1 fim2c)  
 lm2x = geomEncloseRect( lm2xa 35.005 35.005 )   
 m2holed = geomAnd(m2holespace lm2x)  
 m2exd_sz1 =  geomSize( geomSize( m2exd -1.0 noClipAcute ) 1.0 noClipAcute )   
 m2exd_sz1_sz1 =  geomSize( geomSize( m2exd_sz1 -17.5 ) 17.5 )   
 ams1m2_a = geomAnd(m2exd_sz1_sz1 m2exd)  
 errorLayer( geomEncloseRect( ams1m2_a 35.005 35.005 ) 
	"AMS.1.M2  Wide Metal (>35um) must have slot. ")  
geomConnect(
	buttOrOver(m2holed lm2x)
)
processAntenna(
	gate((lm2x m2holed))
        antenna( m2holed )
        ratio = m2holed.area/lm2x.area
      drcAntenna( m2holed lm2x ratio keep < 0.015  
	"AMS.DN.M2  Min. Hole density for metal lines that need to apply slot  1.5% ")
)
m2exd_out2 = geomHoles( m2exd innermostEmpty )
 m2hoc = m2exd_out2  
 m2hod = geomSize( geomSize( m2hoc -5 ) 5 )  /*  Assume Metal Slot < 10um */ 
 m2ho = geomOutside( m2hoc m2hod  )  /*  Metal slot (include not in wide metal) */ 
 fim2 = geomOr(m2exd m2ho)  /*  Metal with slot fill in */
 fim2_sz1 =  geomSize( geomSize( fim2 -17.5 noClipAcute ) 17.5 noClipAcute )   
 m2wma1 = geomAnd(fim2_sz1 fim2)  
 m2wma = geomEncloseRect( m2wma1 35.005 35.005 )   
 m2wm = geomAndNot(m2wma geomOutside(m2wma m2ho ))   
 m2slt = geomInside( m2ho m2wm  )   
m2wmd = geomAnd(m2wma m2exd)  
 m2wme = geomButtOnly(geomOutside(m2wmd m2slt) m2slt )   
 s_fim2 = geomAndNot(m2xd m2wme) 
 s_fim2e = geomGetEdge( s_fim2 butting m2wme ) /* check edge */
 g_fim2e = geomGetLength( s_fim2e keep >= 10 contiguous ) /* good edge */
 g_fim2eg = geomSize( g_fim2e 0.005 edges unmergedOut )
 m2wmeg = geomSize( m2wme 0.005 edges unmergedOut )
 b_fim2e = geomButtOrOver( m2wmeg s_fim2 )   
 errorLayer( geomAndNot( b_fim2e geomButtOrOver( b_fim2e g_fim2eg )) 
	"AM.W.1.M2  Min. width for metal connected to wide metal 10um. ")

pad_exd3 = geomSizeAndProc( pad_exd m3xd 0.32 2 )  
 slt_exdt_or1 =  geomOr(slt_exdt pad_exd3)  
 m3exd = geomAndNot(m3xd slt_exdt_or1)  
/* M3 SLOT CHECKS */
/* ============== */
m3exd_out1 = geomHoles( m3exd innermost )
 m3innerhole = m3exd_out1  
 m3bighole = geomSize( m3innerhole -5 noClipAcute )   
 m3hole = geomOutside( m3innerhole m3bighole  )   
 m3holespace = geomAndNot(m3hole m3exd)  
 fim3c = geomOr(m3exd m3holespace)  
 fim3c_sz1 =  geomSize( geomSize( fim3c -1.0 noClipAcute ) 1.0 noClipAcute )   
 fim3c_sz1_sz1 =  geomSize( geomSize( fim3c_sz1 -17.5 ) 17.5 )   
 lm3xa = geomAnd(fim3c_sz1_sz1 fim3c)  
 lm3x = geomEncloseRect( lm3xa 35.005 35.005 )   
 m3holed = geomAnd(m3holespace lm3x)  
 m3exd_sz1 =  geomSize( geomSize( m3exd -1.0 noClipAcute ) 1.0 noClipAcute )   
 m3exd_sz1_sz1 =  geomSize( geomSize( m3exd_sz1 -17.5 ) 17.5 )   
 ams1m3_a = geomAnd(m3exd_sz1_sz1 m3exd)  
 errorLayer( geomEncloseRect( ams1m3_a 35.005 35.005 ) 
	"AMS.1.M3  Wide Metal (>35um) must have slot. ")  
geomConnect(
	buttOrOver(m3holed lm3x)
)
processAntenna(
	gate((lm3x m3holed))
        antenna( m3holed )
        ratio = m3holed.area/lm3x.area
      drcAntenna( m3holed lm3x ratio keep < 0.015  
	"AMS.DN.M3  Min. Hole density for metal lines that need to apply slot  1.5% ")
)
m3exd_out2 = geomHoles( m3exd innermostEmpty )
 m3hoc = m3exd_out2  
 m3hod = geomSize( geomSize( m3hoc -5 ) 5 )  /*  Assume Metal Slot < 10um */ 
 m3ho = geomOutside( m3hoc m3hod  )  /*  Metal slot (include not in wide metal) */ 
 fim3 = geomOr(m3exd m3ho)  /*  Metal with slot fill in */
 fim3_sz1 =  geomSize( geomSize( fim3 -17.5 noClipAcute ) 17.5 noClipAcute )   
 m3wma1 = geomAnd(fim3_sz1 fim3)  
 m3wma = geomEncloseRect( m3wma1 35.005 35.005 )   
 m3wm = geomAndNot(m3wma geomOutside(m3wma m3ho ))   
 m3slt = geomInside( m3ho m3wm  )   
m3wmd = geomAnd(m3wma m3exd)  
 m3wme = geomButtOnly(geomOutside(m3wmd m3slt) m3slt )   
 s_fim3 = geomAndNot(m3xd m3wme) 
 s_fim3e = geomGetEdge( s_fim3 butting m3wme ) /* check edge */
 g_fim3e = geomGetLength( s_fim3e keep >= 10 contiguous ) /* good edge */
 g_fim3eg = geomSize( g_fim3e 0.005 edges unmergedOut )
 m3wmeg = geomSize( m3wme 0.005 edges unmergedOut )
 b_fim3e = geomButtOrOver( m3wmeg s_fim3 )   
 errorLayer( geomAndNot( b_fim3e geomButtOrOver( b_fim3e g_fim3eg )) 
	"AM.W.1.M3  Min. width for metal connected to wide metal 10um. ")

/* MD SLOT CHECKS */
/* ============== */
/*  Bonding pad, chip corner dummy pad, and inductor need not put slot */
ubm_exdd = geomSizeAndProc( ubmi mdxd 0.32 2 )  /*  For RDL */
 dpdmy_or1 =  geomOr(dpdmy ubm_exdd)  
 mdexd = geomAndNot(mdxd dpdmy_or1)  
mdexd_out1 = geomHoles( mdexd innermost )
 mdinnerhole = mdexd_out1  
 mdbighole = geomSize( mdinnerhole -5 noClipAcute )  /*  Holes with width less than 10um will be filled back */ 
 mdhole = geomOutside( mdinnerhole mdbighole  )   
 mdholespace = geomAndNot(mdhole mdexd)  
 fimdc = geomOr(mdexd mdholespace)  
 fimdc_sz1 =  geomSize( geomSize( fimdc -1.0 noClipAcute ) 1.0 noClipAcute )   
 fimdc_sz1_sz1 =  geomSize( geomSize( fimdc_sz1 -17.5 ) 17.5 )   
 lmdxa = geomAnd(fimdc_sz1_sz1 fimdc)  
 lmdx = geomEncloseRect( lmdxa 35.005 35.005 )   
 mdholed = geomAnd(mdholespace lmdx)  
 mdexd_sz1 =  geomSize( geomSize( mdexd -1.0 noClipAcute ) 1.0 noClipAcute )   
 mdexd_sz1_sz1 =  geomSize( geomSize( mdexd_sz1 -17.5 ) 17.5 )   
 ams1md_a = geomAnd(mdexd_sz1_sz1 mdexd)  
 errorLayer( geomEncloseRect( ams1md_a 35.005 35.005 ) 
	"AMS.1.MD  Wide Metal (>35um) must have slot ")  
geomConnect(
	buttOrOver(mdholed lmdx)
)
processAntenna(
	gate((lmdx mdholed))
        antenna( mdholed )
        ratio = mdholed.area/lmdx.area
      drcAntenna( mdholed lmdx ratio keep < 0.015  
	"AMS.DN.MD  Min. Hole density for metal lines that need to apply slot  1.5% ")
)
mdexd_out2 = geomHoles( mdexd innermostEmpty )
 mdhoc = mdexd_out2  
 mdhod = geomSize( geomSize( mdhoc -5 ) 5 )  /*  Assume Metal Slot < 10um */ 
 mdho = geomOutside( mdhoc mdhod  )  /*  Metal slot (include not in wide metal) */ 
 fimd = geomOr(mdexd mdho)  /*  Metal with slot fill in */
 fimd_sz1 =  geomSize( geomSize( fimd -17.5 noClipAcute ) 17.5 noClipAcute )   
 mdwma1 = geomAnd(fimd_sz1 fimd)  
 mdwma = geomEncloseRect( mdwma1 35.005 35.005 )   
 mdwm = geomAndNot(mdwma geomOutside(mdwma mdho ))   
 mdslt = geomInside( mdho mdwm  )   
mDwmd = geomAnd(mdwma mdexd)  
 mDwme = geomButtOnly(geomOutside(mDwmd mdslt) mdslt )   
 s_fimD = geomAndNot(mdxd mDwme) 
 s_fimDe = geomGetEdge( s_fimD butting mDwme ) /* check edge */
 g_fimDe = geomGetLength( s_fimDe keep >= 10 contiguous ) /* good edge */
 g_fimDeg = geomSize( g_fimDe 0.005 edges unmergedOut )
 mDwmeg = geomSize( mDwme 0.005 edges unmergedOut )
 b_fimDe = geomButtOrOver( mDwmeg s_fimD )   
 errorLayer( geomAndNot( b_fimDe geomButtOrOver( b_fimDe g_fimDeg )) 
	"AM.W.1.MD  Min. width for metal connected to wide metal 10um. ")

/* I/O ESD Guidance  */
/* ================ */
 epact = geomAnd(pact sdi)  
 enact = geomAnd(nact sdi)  
 co_and1 =  geomAnd(co sdi)  
 eco = geomAnd(co_and1 od)  
 epmos = geomEnclose( epact all_gate  )   
 enmos = geomEnclose( enact all_gate  )   
 egte = geomAnd(all_gate sdi)  
 egte_w = geomGetEdge(egte inside od)   
 epsd = geomAndNot(epmos egte)  
 ensd = geomAndNot(enmos egte)  
 ensd_not1 =  geomAndNot(ensd geomButtOrOver(ensd eco ))   
 ensd_nco = geomAndNot(ensd_not1 geomButtOrOver(ensd_not1 ptap ))   
 ensd_wco = geomAndNot(ensd ensd_nco)  
 ensd_src = geomOutside( ensd_wco rpo  )   
 esd1_gate = geomAnd(egte esd1dmy)  
 esd1_ncs_gate = geomAndNot(esd1_gate geomButtOrOver(esd1_gate ensd_nco ))   
 enmos_and1 =  geomAnd(enmos esd1dmy)  
 esd1_tol = geomButtOrOver( enmos_and1 ensd_nco  )   
 enmos_and2 =  geomAnd(enmos esd1dmy)  
 esd1_ncs = geomAndNot(enmos_and2 geomButtOrOver(enmos_and2 ensd_nco ))   
 ensd_nco_esd1dmy = geomButtOrOver( ensd_nco esd1dmy  )   
 esd1_tol_gate = geomButtOrOver( egte ensd_nco_esd1dmy  )   
 esd1_tol_gate1 = geomAndNot(esd1_tol_gate geomButtOrOver(esd1_tol_gate ensd_src ))   
 esd1_tol_gate2 = geomButtOrOver( esd1_tol_gate ensd_src  )   
 esd1_tol_gate2_w = geomGetEdge(esd1_tol_gate2 inside od)   
 esd2_gate = geomAnd(egte esd2dmy)  
 esd2_reg_gate = geomAndNot(esd2_gate geomButtOrOver(esd2_gate ensd_nco ))   
 esd2_tol_gate = geomButtOrOver( esd2_gate ensd_nco  )   
 esd2_tol_gate1 = geomAndNot(esd2_tol_gate geomButtOrOver(esd2_tol_gate ensd_src ))   
 esd2_tol_gate2 = geomButtOrOver( esd2_tol_gate ensd_src  )   
 enmos_and3 =  geomAnd(enmos esd2dmy)  
 esd2_tol = geomButtOrOver( enmos_and3 ensd_nco  )   
 enmos_and4 =  geomAnd(enmos esd2dmy)  
 esd2_reg = geomAndNot(enmos_and4 geomButtOrOver(enmos_and4 ensd_nco ))   
 rpo_and2 =  geomAnd(rpo sdi)  
 rpo_and2_out1 =  geomOutside( rpo_and2 esd1dmy  )   
 rpo1 = geomOutside( rpo_and2_out1 esd2dmy  )   
 egte_out1 =  geomOutside( egte esd1dmy  )   
 egte_out1_out1 =  geomOutside( egte_out1 esd2dmy  )   
 egte1 = geomAndNot(egte_out1_out1 geomButtOrOver(egte_out1_out1 ensd_nco ))   
 egte1_w = geomGetEdge(egte1 inside od)   
 erpo = geomAnd(rpo sdi)  
erpo_out1 = geomHoles(erpo)
 erpoh = erpo_out1  
 erpoa = geomOr(erpoh erpo)  
 ecos = geomOutside( eco erpoa  )   
 hegt = geomAnd(egte od2)  
 legt = geomAndNot(egte od2)  
 hegn = geomAnd(hegt np)  
 hegp = geomAnd(hegt pp)  
if(!(HIGH_VOLTAGE == 5) then
 errorLayer( geomAnd(esd1dmy gate_pp) 
	"ESD.22  ESD1DMY is for NMOS only / ESD2DMY is for 3.3V NMOS only ") 
 errorLayer( geomAnd(esd2dmy gate_pp) 
	"ESD.22 2  ESD1DMY is for NMOS only / ESD2DMY is for 3.3V NMOS only ") 
 gate_np_not1 =  geomAndNot(gate_np od2)  
 errorLayer( geomAnd(esd2dmy gate_np_not1) 
	"ESD.22 3  ESD1DMY is for NMOS only / ESD2DMY is for 3.3V NMOS only ") 
 errorLayer( geomGetLength(egte_w  keep < 20 contiguous ) 
	"ESD.GUIDE.4  I/O - Gate 20um <= width <= 60um. ")  
 errorLayer( geomGetLength(egte_w  keep > 60 contiguous ) 
	"ESD.GUIDE.4 2  I/O - Gate 20um <= width <= 60um. ")  
 esd5a_x = geomAndNot(esd2_tol_gate rpo)  
 errorLayer( geomAndNot(esd2_tol geomButtOrOver(esd2_tol esd5a_x )) 
	"ESD.5A  For 3.3V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and overlap 2nd poly gate >= 0.05um ")  
 errorLayer( geomOutside( esd2_tol_gate2 rpo  ) 
	"ESD.5A 2  For 3.3V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and overlap 2nd poly gate >= 0.05um ")  
 errorLayer( geomAndNot(esd2_tol_gate1 rpo) 
	"ESD.5A 3  For 3.3V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and overlap 2nd poly gate >= 0.05um ") 
 drc( esd2_tol_gate2 rpo  ovlp < 0.05  opposite shielded withIntersection 
	"ESD.5A 4  For 3.3V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and overlap 2nd poly gate >= 0.05um ")  
/* For 3.3V high voltage tolerant NMOS, 1st and 2nd poly gate spacing is >=0.25um  */
/* is checked by ESD.5H */
 esd5b_x = geomAnd(esd1_tol_gate rpo)  
 errorLayer( geomAndNot(esd1_tol geomButtOrOver(esd1_tol esd5b_x )) 
	"ESD.5B  For 1.8V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and should not cover 2nd poly gate, RPO space to 2nd poly gate >= 0.25um ")  
 errorLayer( geomAndNot(esd1_tol_gate1 rpo) 
	"ESD.5B 2  For 1.8V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and should not cover 2nd poly gate, RPO space to 2nd poly gate >= 0.25um ") 
 errorLayer( geomAnd(esd1_tol_gate2 rpo) 
	"ESD.5B 3  For 1.8V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and should not cover 2nd poly gate, RPO space to 2nd poly gate >= 0.25um ") 
 esd5b1_y = geomButtOrOver( rpo esd1_tol_gate1  )   
 drc( esd5b1_y esd1_tol_gate2_w  sep < 0.25  opposite shielded withIntersection 
	"ESD.5B 4  For 1.8V high voltage tolerant NMOS, RPO should completely cover 1st poly gate and should not cover 2nd poly gate, RPO space to 2nd poly gate >= 0.25um ")  
/* For 1.8V high voltage tolerant NMOS, 1st and 2nd poly gate spacing is >=0.25um */
/* is checked by ESD.5I */
 esd5c_x = geomAndNot(esd2_reg_gate rpo)  
 errorLayer( geomAndNot(esd2_reg geomButtOrOver(esd2_reg esd5c_x )) 
	"ESD.5C  For 3.3V regular NMOS, RPO needs to overlap poly gate >= 0.05um ")  
 errorLayer( geomOutside( esd2_reg_gate rpo  ) 
	"ESD.5C 2  For 3.3V regular NMOS, RPO needs to overlap poly gate >= 0.05um ")  
 drc( esd2_reg_gate rpo  ovlp < 0.05  opposite shielded withIntersection 
	"ESD.5C 3  For 3.3V regular NMOS, RPO needs to overlap poly gate >= 0.05um ")  
 errorLayer( geomAndNot(esd1_ncs_gate rpo) 
	"ESD.5D  For the grounded gate ESD protection device between Vcc/Vss, RPO should fully cover all poly gate and source drain. ") 
 drc( rpo1 egte1_w  sep < 0.45  opposite shielded withIntersection 
	"ESD.5E  For all PMOS and 1.8V regular NMOS, RPO space to gate 0.45um ")  
 errorLayer( geomAnd(egte1 rpo1) 
	"ESD.5E 2  For all PMOS and 1.8V regular NMOS, RPO space to gate 0.45um ") 
 ensd_wco_and1 =  geomAnd(ensd_wco esd2dmy)  
 esd5f_x = geomAnd(ensd_wco_and1 rpo)  
 drc( esd5f_x   width < 1.95  
	"ESD.5F  For 3.3V high voltage tolerant, 3.3V regular NMOS, and 1.8V NMOS high voltage tolerant min. width of RPO on drain side and RPO edge to OD edge 1.95um ")  
 ensd_wco_and2 =  geomAnd(ensd_wco esd1dmy)  
 ensd_wco_and21 =  geomAnd(ensd_wco_and2 rpo)  
 esd5f1_z = geomButtOrOver( ensd_wco_and21 esd1_tol_gate1  )   
 drc( esd5f1_z   width < 1.95  
	"ESD.5F 2  For 3.3V high voltage tolerant, 3.3V regular NMOS, and 1.8V NMOS high voltage tolerant min. width of RPO on drain side and RPO edge to OD edge 1.95um ")  
 esd5g_y = geomAnd(rpo1 od)  
 drc( esd5g_y   width < 1.5  
	"ESD.5G  For 1.8V regular NMOS and all PMOS  min. width of RPO on drain side and RPO edge to OD edge 1.5um ")  
 esd5h_x = geomButtOrOver( ensd_nco esd2dmy  )   
 drc( esd5h_x   width < 0.25  
	"ESD.5H  For 3.3V high voltage tolerant NMOS, 1st and 2nd poly gate spacing is >=0.25um ")  
 drc( ensd_nco_esd1dmy   width < 0.25  
	"ESD.5I  For 1.8V high voltage tolerant NMOS, 1st and 2nd poly gate spacing is >=0.25um ")  
 drc( ecos egte_w  sep < 0.75  opposite shielded withIntersection 
	"ESD.6  Min. space between CO on source side to poly gate 0.75um ")  
 esd6_x = geomAnd(eco esd1_ncs)  
 drc( esd6_x egte_w  sep < 0.75  opposite shielded withIntersection 
	"ESD.6 2  Min. space between CO on source side to poly gate 0.75um ")  
 epsd_or1 =  geomOr(epsd ensd)  
 esdwarn1_red = geomButtOrOver( epsd_or1 rpo1  )   
 esdwarn11_xrpo = geomAndNot(esdwarn1_red rpo1)  
 esdwarn12_xrpg = geomButtOnly(geomOutside(esdwarn11_xrpo egte1) egte1 )   
 errorLayer( geomButtOrOver( esdwarn12_xrpg eco  ) 
	"ESD.WARN.1  CO can't inserted between gate and RPO for 1.8V NMOS and all PMOS I/O pattern. ")  
if((CORE_VOLTAGE == 1.5) then
 drc( legt   width < 0.25  withCornerTouch 
	"ESD.9A  1.5V IO ESD NMOS/PMOS gate length < 0.25um ")  
) ; 
if((CORE_VOLTAGE == 1.8) then
 drc( legt   width < 0.25  withCornerTouch 
	"ESD.9A 2  1.8V IO ESD NMOS/PMOS gate length < 0.25um ")  
) ; 
if((HIGH_VOLTAGE == 2.5) then
 drc( hegn   width < 0.3  withCornerTouch 
	"ESD.9B  2.5V IO ESD NMOS gate length < 0.3um ")  
 drc( hegp   width < 0.3  withCornerTouch 
	"ESD.9C  2.5V IO ESD PMOS gate length < 0.3um ")  
) ; 
if((HIGH_VOLTAGE == 3.3) then
 drc( hegn   width < 0.4  withCornerTouch 
	"ESD.9B 2  3.3V IO ESD NMOS gate length < 0.4um ")  
 drc( hegp   width < 0.3  withCornerTouch 
	"ESD.9C 2  3.3V IO ESD PMOS gate length < 0.3um ")  
) ; 
) ; 
/*  begin of ESD.11, butted or inserted pickup is not allowed */
 esd11_eact = geomOr(epact enact)  
 esd111_dtap = geomOr(ntap ptap)  
esd112_eactup3 = geomSizeAndNot( esd11_eact esd111_dtap 0.22* 0.7 3 )  
 esd113_d1 = geomButtOrOver( esd111_dtap esd112_eactup3  )   
esd114_d1r1 = geomGrow( esd113_d1 -0.001 0 0 0 ) 
 esd115_d1r2 = geomAndNot(esd113_d1 esd114_d1r1)  
 esd116_d1r3 = geomGetEdge(esd113_d1 coincident esd115_d1r2)   
 esd117_d1r4 = geomGetLength( esd116_d1r3  keep > 0.001 )   
 esd118_d1r5 = drc( esd117_d1r4 esd11_eact  sep < 3  opposite shielded withIntersection edgea )
 esd118_d1r5_sz1 = geomSize(esd118_d1r5 0.005 edges)
 esd119_d1l = geomButtOrCoin( esd113_d1 esd118_d1r5_sz1 )   
esd1110_d1l1 = geomGrow( esd119_d1l 0 0 -0.001 0 ) 
 esd1111_d1l2 = geomAndNot(esd119_d1l esd1110_d1l1)  
 esd1112_d1l3 = geomGetEdge(esd119_d1l coincident esd1111_d1l2)   
 esd1113_d1l4 = geomGetLength( esd1112_d1l3  keep > 0.001 )   
 esd1114_d1l5 = drc( esd1113_d1l4 esd11_eact  sep < 3  opposite shielded withIntersection edgea )
 esd1114_d1l5_sz1 = geomSize(esd1114_d1l5 0.005 edges)
 esd1115_d1x = geomButtOrCoin( esd119_d1l esd1114_d1l5_sz1 )   
esd1116_d1t1 = geomGrow( esd113_d1 0 -0.001 0 0 ) 
 esd1117_d1t2 = geomAndNot(esd113_d1 esd1116_d1t1)  
 esd1118_d1t3 = geomGetEdge(esd113_d1 coincident esd1117_d1t2)   
 esd1119_d1t4 = geomGetLength( esd1118_d1t3  keep > 0.001 )   
 esd1120_d1t5 = drc( esd1119_d1t4 esd11_eact  sep < 3  opposite shielded withIntersection edgea )
 esd1120_d1t5_sz1 = geomSize(esd1120_d1t5 0.005 edges)
 esd1121_d1b = geomButtOrCoin( esd113_d1 esd1120_d1t5_sz1 )   
esd1122_d1b1 = geomGrow( esd1121_d1b 0 0 0 -0.001 ) 
 esd1123_d1b2 = geomAndNot(esd1121_d1b esd1122_d1b1)  
 esd1124_d1b3 = geomGetEdge(esd1121_d1b coincident esd1123_d1b2)   
 esd1125_d1b4 = geomGetLength( esd1124_d1b3  keep > 0.001 )   
 esd1126_d1b5 = drc( esd1125_d1b4 esd11_eact  sep < 3  opposite shielded withIntersection edgea )
 esd1126_d1b5_sz1 = geomSize(esd1126_d1b5 0.005 edges)
 esd1127_d1y = geomButtOrCoin( esd1121_d1b esd1126_d1b5_sz1 )   
 errorLayer( geomCat(esd1127_d1y) 
	"ESD.11 3  Butting or inserted pickup between source diffusion of ESD devices are prohibited ")  
 esd1128_dtap2check = geomOr(esd1115_d1x esd1127_d1y)  
esd1128_dtap2check5 = geomHoles( esd1128_dtap2check innermost )
 esd1129_dtaphole = esd1128_dtap2check5  
 esd1130_dtapsuspect =  geomAndNot(esd1128_dtap2check geomButtOnly(geomOutside(esd1128_dtap2check esd1129_dtaphole) esd1129_dtaphole ))   
 errorLayer( geomEncloseRect( esd1130_dtapsuspect 20 0.22 ) 
	"ESD.11 5  Butting or inserted pickup between source diffusion of ESD devices are prohibited ")  
/*  LATCH-UP CHECKS */
/* ================== */
 pact_enc1 =  geomEnclose( pact all_gate  )  /* Interact CONTi to filter out filler cell. */ 
 pmos = geomButtOrOver( pact_enc1 coi  )  /* Interact CONTi to filter out filler cell. */ 
 nact_enc1 =  geomEnclose( nact all_gate  )   
 nmos = geomButtOrOver( nact_enc1 coi  )   
 pasd = geomAndNot(pmos all_gate)  
 nasd = geomAndNot(nmos all_gate)  
 drc( epmos enmos 0 < sep < 15  shielded withIntersection withSingularPoint 
	"LAT.2  I/O - NMOS to PMOS space < 15um ")  
pasd_lat1 = geomSepInside( pasd 30 ntap nweli anyOutside )
errorLayer( pasd_lat1 
	"LAT.3P  N-Well Pick-Up OD to PMOS space > 30um ")

nasd_lat1 = geomSepInside( nasd 30 ptap pweli anyOutside )
errorLayer( nasd_lat1 
	"LAT.3N  P-Well Pick-Up OD to NMOS space > 30um ")

/*  POLY CHECKS */
/* ============== */
 drc( hrep   width < 1.0  withCornerTouch 
	"_PO.W.1.MM  Min. width of PO region for HRI poly resistor >= 1.0um ")  
 _por1amm_norm_gate_w = geomGetEdge(gate_w outside vardmy)   
 _por1amm_norm_gate_w1 = geomGetAngledEdge(_por1amm_norm_gate_w keep == 0)
 _por1amm_norm_gate_w11 = geomGetAdjacentEdge(_por1amm_norm_gate_w _por1amm_norm_gate_w1 )
 _por1amm_norm_gate_w2 = geomGetAngledEdge(_por1amm_norm_gate_w keep == 45)
 errorLayer( geomAndNot(_por1amm_norm_gate_w11 _por1amm_norm_gate_w2) 
	"_PO.R.1A.MM  90 degree L shape and U shape bent gates are not allowed ") 
/*  PP CHECKS */
/* ============ */
 drc( pp pores  enc < 0.18  shielded withIntersection withSingularPoint 
	"_PP.E.6.MM  Min. extension of a PP region beyond a PO as resistor >= 0.18um ")  
 rpo_and3 =  geomAnd(rpo poly)  
 rpo_and3_not1 =  geomAndNot(rpo_and3 imp)  
 errorLayer( geomAndNot(rpo_and3_not1 hri) 
	"_PP.E.6.MM 2  Min. extension of a PP region beyond a PO as resistor >= 0.18um ") 
/*  RPO CHECKS */
/* ============= */
 _rpoo1mm_x = geomButtOrOver( poly_iso hri  )   
 _rpoo1mm1_y = geomGetEdge(rpo inside _rpoo1mm_x)   
 drc( pp _rpoo1mm1_y  ovlp < 0.3  shielded withIntersection 
	"_RPO.O.1.MM  Min. and Max. overlap of a PP region to RPO region for HRI >= 0.3um ")  
 errorLayer( geomGetEdge(_rpoo1mm1_y outside pp) 
	"_RPO.O.1.MM 2  Min. and Max. overlap of a PP region to RPO region for HRI >= 0.3um ") /*  not overlap by P+ not allowed. */ 
 _rpoo1mm2_z = geomSize(_rpoo1mm1_y -0.30 edges)   
 _rpoo1mm3_pppo = geomAnd(pp poly)  
 _rpoo1mm4_a = geomAnd(_rpoo1mm3_pppo pores)  
 _rpoo1mm5_b = geomButtOrOver( _rpoo1mm4_a hri  )   
 errorLayer( geomAndNot(_rpoo1mm5_b _rpoo1mm2_z) 
	"_RPO.O.1.MM 3  Min. and Max. overlap of a PP region to RPO region for HRI >= 0.3um ") 
/*  DNW CHECKS */
/* ============== */
 errorLayer( geomAnd(dnw rwdmy) 
	"DNW.I.6  It is not allowed to use DNW as a resistor ") 
 errorLayer( geomButtOrOver( rnwel dnw  ) 
	"DNW.I.7  It is not allowed to use {NW interact DNW} as a resistor ")  
 errorLayer( geomButtOrOver( nwres dnw  ) 
	"DNW.I.7 2  It is not allowed to use {NW interact DNW} as a resistor ")  
 drc( dnw   width < 3  withCornerTouch 
	"DNW.W.1  Min. width of a DNW region >= 3um ")  
 drc( dnw   sepNotch < 5  
	"DNW.S.1  Min. space between two DNW regions >= 5um ")  
 drc( dnw nwel  ovlp < 2.0  shielded withIntersection withSingularPoint 
	"DNW.O.1  Min. overlap from a NW edge to a DNW region >= 2.0um ") /*  MEASURE COINCIDENT */ 
 dnwc1_x = geomOutside( nwel dnw  )   
 drc( dnw dnwc1_x  sep < 3.5  shielded withIntersection withSingularPoint 
	"DNW.C.1  Min. clearance from DNW to NW >= 3.5um ")  
 dnwc4_a = geomAndNot(pwel dnw)  
 dnwc41_b = geomButtOrOver( npod dnwc4_a  )   
 drc( dnwc41_b dnw  sep < 3.0  shielded withIntersection withSingularPoint 
	"DNW.C.4  Min. clearance from DNW to N+OD outside NW >= 3.0um ")  
 errorLayer( geomStraddle( dnwc41_b dnw  ) 
	"DNW.C.4 2  Min. clearance from DNW to N+OD outside NW >= 3.0um ")  
 dnwe2_a = geomAnd(pwel dnw)  
 dnwe21_b = geomButtOrOver( npod dnwe2_a  )   
 drc( dnw dnwe21_b  enc < 1.5  shielded withIntersection withSingularPoint 
	"DNW.E.2  Min. extension of DNW beyond N+OD outside NW >= 1.5um ")  
 errorLayer( geomStraddle( dnwe21_b dnw  ) 
	"DNW.E.2 2  Min. extension of DNW beyond N+OD outside NW >= 1.5um ")  
if((Recommend == 1) then
/*  DNW.I.5 is a recommended rule and un-checkable. */
 drc( nwel dnw  enc < 1.5  shielded withIntersection withSingularPoint 
	"DNW.E.1  Min. extension of NW beyond DNW for a better noise isolation >= 1.5um ")  
 errorLayer( geomGetEdge(dnw outside nwel) 
	"DNW.E.1 2  Min. extension of NW beyond DNW for a better noise isolation >= 1.5um ")  
) ; 
if(!(HIGH_VOLTAGE == 5) then
/*  NT_N For Mix-Mode Circuit */
/* ========================== */
 errorLayer( geomAnd(ntn dnw) 
	"_NT_N.I.1.MM  NT_N interact DNW is not allowed. (Butted is allowed) ") 
/* NT_N.I.2.MM is checked by NT_N.C.2 in Logic section */
/* NT_N.I.3.MM is checked by NT_N.I.2 in Logic section */
/* NT_N.I.4.MM is the same as NT_N.I.3 in Logic section */
/* NT_N.I.5.MM is checked by NT_N.I.4 in Logic section */
 drc( ntn_od poly_iso 0 < sep < 0.26  shielded withIntersection withSingularPoint 
	"_NT_N.I.6.MM  Min. clearance from an OD region in NTN region to a PO on field oxide >= 0.26um ")  
/* NT_N.W.1.MM is checked by NT_N.W.1 in Logic section */
/* NT_N.W.2.MM is checked by NT_N.W.2 in Logic section */
/* NT_N.W.3.MM is checked by NT_N.W.2B in Logic section */
/* NT_N.S.1.MM is checked by NT_N.S.1 in Logic region */
/* NT_N.E.1.MM is the same as NT_N.E.1 in Logic section */
/* NT_N.C.1.MM is checked by NT_N.C.1 in Logic region */
/* NT_N.C.2.MM is checked by NT_N.C.2 in Logic region */
/* NT_N.PO.1.MM is checked by NT_N.PO.1 in Logic region */
) ; /* #IFNDEF 5V */
/* VTM_N */
/* ===== */
 errorLayer( geomAnd(vtmn dnw) 
	"VTMN.I.1  VTM_N interact DNW is not allowed ") 
 errorLayer( geomAnd(vtmn ntn) 
	"VTMN.I.2  VTM_N interact NT_N is not allowed ") 
 errorLayer( geomAnd(vtmn gate_pp) 
	"VTMN.I.3  A P+ Gate is not allowed in VTM_N region ") 
 vtmni4_vtmn_po = geomAnd(poly vtmn)  
 errorLayer( geomGetVertex(vtmni4_vtmn_po ignore == 4) 
	"VTMN.I.4  A bent PO region is not allowed in VTM_N region ")  
 vtmni5_vtmn_od = geomAnd(vtmn od)  
 drc( vtmni5_vtmn_od poly_iso 0 < sep < 0.26  shielded withIntersection withSingularPoint 
	"VTMN.I.5  Min. clearance from an OD region in VTM_N region to a PO on field oxide >= 0.26um ")  
 drc( vtmn   width < 0.74  withCornerTouch 
	"VTMN.W.1  Min. dimension of a VTM_N region >= 0.74um ")  
 vtmnw2_z = geomGetEdge(gate_w inside vtmn)   
 drc( vtmnw2_z   width < 0.3  
	"VTMN.W.2  Min. PO gate dimension of a 1.8V medium Vt NMOS >= 0.3um ")  
 vtmnw3_z = geomGetEdge(hv_ngate_w inside vtmn)   
 drc( vtmnw3_z   width < 0.6  
	"VTMN.W.3  Min. PO gate dimension of a 3.3V medium Vt NMOS >= 0.6um ")  
 drc( vtmn   sepNotch < 0.44  
	"VTMN.S.1  Min. space between two VTM_N regions >= 0.44um ")  
 drc( vtmn nact  enc < 0.26  shielded withIntersection withSingularPoint 
	"VTMN.E.1  Min. extension from a VTM_N region beyond an N+OD region >= 0.26um ")  
 errorLayer( geomStraddle( nact vtmn  ) 
	"VTMN.E.1 2  Min. extension from a VTM_N region beyond an N+OD region >= 0.26um ")  
 drc( nact vtmn  sep < 0.7  shielded withIntersection withSingularPoint 
	"VTMN.C.1  Min. clearance from a VTM_N region to an N+OD region >= 0.7um ")  
 drc( vtmn nwel  sep < 0.43  shielded withIntersection withSingularPoint 
	"VTMN.C.2  Min. clearance from a VTM_N region to an NW edge >= 0.43um ")  
 errorLayer( geomAnd(vtmn nwel) 
	"VTMN.C.2 2  Min. clearance from a VTM_N region to an NW edge >= 0.43um ") 
/*  VTM_P */
/* ====== */
 errorLayer( geomAnd(vtmp dnw) 
	"VTMP.I.1  VTM_P interact DNW is not allowed ") 
 errorLayer( geomAnd(vtmp ntn) 
	"VTMP.I.2  VTM_P interact NT_N is not allowed ") 
 errorLayer( geomAnd(vtmp gate_np) 
	"VTMP.I.3  A N+ Gate is not allowed in VTM_P region ") 
 vtmpi4_vtmp_po = geomAnd(poly vtmp)  
 errorLayer( geomGetVertex(vtmpi4_vtmp_po ignore == 4) 
	"VTMP.I.4  A bent PO region is not allowed in VTM_P region ")  
 vtmpi5_vtmp_od = geomAnd(vtmp od)  
 drc( vtmpi5_vtmp_od poly_iso 0 < sep < 0.26  shielded withIntersection withSingularPoint 
	"VTMP.I.5  Min. clearance from an OD region in VTM_P region to a PO on field oxide >= 0.26um ")  
 drc( vtmp   width < 0.74  withCornerTouch 
	"VTMP.W.1  Min. dimension of a VTM_P region >= 0.74um ")  
 vtmpw2_z = geomGetEdge(gate_w inside vtmp)   
 drc( vtmpw2_z   width < 0.25  
	"VTMP.W.2  Min. PO gate dimension of a 1.8V medium Vt PMOS >= 0.25um ")  
 drc( vtmp   sepNotch < 0.44  
	"VTMP.S.1  Min. space between two VTM_P regions >= 0.44um ")  
 drc( vtmp pact  enc < 0.26  shielded withIntersection withSingularPoint 
	"VTMP.E.1  Min. extension from a VTM_P region beyond a P+OD region >= 0.26um ")  
 errorLayer( geomStraddle( pact vtmp  ) 
	"VTMP.E.1 2  Min. extension from a VTM_P region beyond a P+OD region >= 0.26um ")  
 drc( pact vtmp  sep < 0.7  shielded withIntersection withSingularPoint 
	"VTMP.C.1  Min. clearance from a VTM_P region to a P+OD region >= 0.7um ")  
 drc( nwel vtmp  enc < 0.43  shielded withIntersection withSingularPoint 
	"VTMP.C.2  Min. clearance from a VTM_P region to a PW edge >= 0.43um ")  
 errorLayer( geomAndNot(vtmp nwel) 
	"VTMP.C.2 2  Min. clearance from a VTM_P region to a PW edge >= 0.43um ") 
 vtmpr1_z = geomAnd(all_gate vtmp)  
 errorLayer( geomAnd(od2 vtmpr1_z) 
	"VTMP.R.1  3.3V medium Vt PMOS is not allowed in VTM_P region ") 
/*  RES CHECK */
/* ========== */
if((Recommend == 1) then
 res1_poresc = geomAndNot(pores geomButtOrOver(pores rlppdmy ))   
 drc( res1_poresc   width < 1.0  withCornerTouch 
	"RES.1  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5 ")  
 res11_res_l = geomGetEdge(res1_poresc coincident poly)   
 res12_x = geomGetLength(res11_res_l  keep < 5.0 contiguous )   
 res12_x_sz1 = geomSize(res12_x 0.005 edges)
 res13_check_res = geomButtOrCoin( res1_poresc res12_x_sz1 )   
 res14_res_e = geomGetEdge(res13_check_res coincident rpo)   
 res15_a = geomSize(res14_res_e -0.005 edges)   
res16_b = geomSizeAndProc( res15_a res1_poresc 0.175 (5.0/2-0.005*2 ) )  
 res17_c = geomAndNot(res13_check_res res16_b)  
 errorLayer( geomAndNot(res13_check_res geomButtOrOver(res13_check_res res17_c )) 
	"RES.1 2  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5 ")  
 res18_d = drc( res17_c   width < 0.005* 2  )
 errorLayer( geomButtOrOver( res13_check_res res18_d  ) 
	"RES.1 3  For poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 5.0um, and the resistor square number Nsq >= 5 ")  
/*  For RES.1, "Nsq >= 5" can not be checked by DRC */
 drc( hrep   width < 1.0  withCornerTouch 
	"RES.2  For HRI poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 2.0um, and the resistor square number Nsq >= 2 ")  
 res2_res_l = geomGetEdge(hrep coincident poly)   
 res21_x = geomGetLength(res2_res_l  keep < 2.0 contiguous )   
 res21_x_sz1 = geomSize(res21_x 0.005 edges)
 res22_check_res = geomButtOrCoin( hrep res21_x_sz1 )   
 res23_res_e = geomGetEdge(res22_check_res coincident rlppdmy)   
 res24_a = geomSize(res23_res_e -0.005 edges)   
res25_b = geomSizeAndProc( res24_a hrep 0.175 (2.0/2-0.005*2 ) )  
 res26_c = geomAndNot(res22_check_res res25_b)  
 errorLayer( geomAndNot(res22_check_res geomButtOrOver(res22_check_res res26_c )) 
	"RES.2 2  For HRI poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 2.0um, and the resistor square number Nsq >= 2 ")  
 res27_d = drc( res26_c   width < 0.005* 2  )
 errorLayer( geomButtOrOver( res22_check_res res27_d  ) 
	"RES.2 3  For HRI poly resistor, it is strongly recommended that the poly resistor width >= 1.0um, length >= 2.0um, and the resistor square number Nsq >= 2 ")  
/*  For RES.2, "Nsq >= 2" can not be checked by DRC */
 res3_po_res = geomButtOrOver( poly pores  )   
 res31_co_res = geomButtOrOver( co res3_po_res  )   
 res32_rpo_e = geomGetEdge(rpo inside res3_po_res)   
 res33_rpo_ex = geomSize(res32_rpo_e 0.22 edges)   
 errorLayer( geomAnd(res33_rpo_ex res31_co_res) 
	"RES.3  Min. and Max. clearance from RPO to a contact on the poly resistor and HRI poly resistor = 0.22um ") 
 errorLayer( geomAndNot(res33_rpo_ex geomButtOrOver(res33_rpo_ex res31_co_res )) 
	"RES.3 2  Min. and Max. clearance from RPO to a contact on the poly resistor and HRI poly resistor = 0.22um ")  
 errorLayer( geomAndNot(res31_co_res geomButtOrOver(res31_co_res res33_rpo_ex )) 
	"RES.3 3  Min. and Max. clearance from RPO to a contact on the poly resistor and HRI poly resistor = 0.22um ")  
 drc( pores imp  sep < 0.26  withIntersection withSingularPoint 
	"RES.4  Min. clearance from poly resistor and HRI poly resistor to un-related NP, PP regions >= 0.26um ")  
 drc( pores rpo  sep < 0.3  withIntersection withSingularPoint 
	"RES.5  Min. clearance from poly resistor and HRI poly resistor to un-related RPO region >= 0.3um ")  
/*  RES.6 is checked by RES.3 */
/*  RES.7 is un-checkable by DRC */
 res8_po_hrep = geomButtOrOver( poly hrep  )   
 drc( rlppdmy res8_po_hrep  enc < 0.26  shielded withIntersection withSingularPoint 
	"RES.8  Min. clearance from RLPPDMY to the HRI poly resistor >= 0.26um ")  
) ; 
/* HRI   */
/* ===   */
 drc( hri   width < 0.44  withCornerTouch 
	"HRI.W.1  Min. width of a HRI region >= 0.44um ")  
 drc( hri   sepNotch < 0.44  
	"HRI.S.1  Min. space between two HRI regions >= 0.44um ")  
 hric1_x = drc( hri np  sep < 0.26  shielded withIntersection withSingularPoint )
 errorLayer( geomAndNot(hric1_x geomButtOrOver(hric1_x butt_ptap )) 
	"HRI.C.1  Min. clearance from an HRI region to an NP region >= 0.26um ")  
 hric11_y = geomGetEdge(np butting hri)   
hric11_y_11 = geomSize(hric11_y 0.001 edges)
hric11_y_21 = geomSize(hric11_y -0.001 edges)
 hric12_z = geomOr(hric11_y_11 hric11_y_21)   
 errorLayer( geomAndNot(hric12_z geomButtOrOver(hric12_z butt_ptap )) 
	"HRI.C.1 2  Min. clearance from an HRI region to an NP region >= 0.26um ")  
 drc( hri pp  sep < 0.26  shielded withIntersection withSingularPoint 
	"HRI.C.2  Min. clearance from an HRI region to a PP region >= 0.26um ")  
 drc( hri all_gate  sep < 0.32  shielded withIntersection withSingularPoint 
	"HRI.C.3_C.4  Min. clearance from an HRI edge to Poly gate >= 0.32um ")  
 drc( hri pores  enc < 0.26  shielded withIntersection withSingularPoint 
	"HRI.E.1  Min. extension from an HRI region beyond a PO resistor region >= 0.26um ")  
 errorLayer( geomAnd(hri np) 
	"HRI.R.1  Overlap of NP and HRI is not allowed ") 
 errorLayer( geomAnd(hri od) 
	"HRI.R.2  Overlap of OD and HRI is not allowed ") 
 drc( hri  area < 0.3844 
	"HRI.A.1  Min. area of a HRI region >= 0.3844um2 ") 
/*  CTM CHECK */
/* ============ */
 tctm = geomButtOrOver( ctm2 via2  )  /*  True CTM */ 
 dctm = geomAndNot(ctm2 geomButtOrOver(ctm2 via2 ))  /*  Dummy CTM */ 
bpm2 = geomSizeAndProc( tctm m2 0.28* 0.7 2 )  /*  CBM = TCTM SIZE 2 */
 dpm2 = geomButtOrOver( m2 dctm  )  /*  M2 as a dummy CBM */ 
 bpm2c = geomGetEdge(bpm2 coincident m2)   
 drc( tctm   width < 4.0  withCornerTouch 
	"CTM.W.1  Min. width of a CTM region >= 4.0um ")  
 drc( dctm   width < 0.4  withCornerTouch 
	"CTM.W.2  Min. width of a dummy CTM region >= 0.4um ")  
 drc( tctm   sepNotch < 1.2  
	"CTM.S.1  Min. space between two CTM regions >= 1.2um ")  
 drc( dctm tctm  sep < 0.8  shielded withIntersection withSingularPoint 
	"CTM.S.2  Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= 0.8um ")  
 drc( dctm   sepNotch < 0.8  
	"CTM.S.2 2  Min. space between a dummy CTM and a CTM region or two dummy CTM regions >= 0.8um ")  
 ctm2i_den1 = drc(ctm2i 0 < coverage < 0.03 )
 errorLayer( geomGetCoverage( ctm2i_den1  0 < keep < 0.03  ) 
	"CTM.R.2  Min. density of all CTM area >= 3% ") 

/* CTM.R.3 is not necessary to check */
 errorLayer( geomEncloseRect( tctm 30.005 4 manhattanOnly) 
	"CTM.W.4  Max. dimension (one side) of a CTM region <= 30um ") /*  4um is min TCTM width */ 
 drc( ctm2  area < 0.202 
	"CTM.A.1  Min. area of CTM region >= 0.202um2 ") 
 drc( m2 ctm2  enc < 0.4  shielded withIntersection withSingularPoint 
	"CTM.E.3  Min. extension of an M2 region as MIM capacitor bottom metal beyond a CTM and dummy CTM region >= 0.4um ")  
 errorLayer( geomAndNot(ctm2 m2) 
	"CTM.E.3 2  Min. extension of an M2 region as MIM capacitor bottom metal beyond a CTM and dummy CTM region >= 0.4um ") 
/* CTM.R.1 is checked by CTM.E.3 */
 errorLayer( geomCat(ctm3) 
	"CTM.R.5  The MIM capacitor must be placed between M3 amd M2 ")  
 errorLayer( geomCat(ctm4) 
	"CTM.R.5 2  The MIM capacitor must be placed between M3 amd M2 ")  
 errorLayer( geomCat(ctm5) 
	"CTM.R.5 3  The MIM capacitor must be placed between M3 amd M2 ")  
/*  MIM_Mx CHECK */
/* ============== */
 errorLayer( geomSize( geomSize( bpm2 -17.5 noClipAcute ) 17.5 noClipAcute ) 
	"MIM_M2.W.1  Max. dimension (both width and length) of M2 as MIM capacitor bottom metal <= 35um ")  
 drc( bpm2c  0 <  sepNotch < 0.8  
	"MIM_M2.S.1  Min. space between two M2 regions as MIM capacitor bottom metal >= 0.8um ")  
 drc( bpm2c dpm2  sep < 0.8  shielded withIntersection 
	"MIM_M2.S.2  Min. space between one M2 region as a dummy MIM capacitor bottom metal and  the other M2 region as MIM capacitor bottom metal >= 0.8um ")  
/*  MIMVIA CHECK */
/* =============== */
 ctmv2 = geomAnd(via2 ctm2)  /*  VIA2 locate on CTM */
 via2_and1 =  geomAnd(via2 bpm2)  /*  VIA2 locate on CBM */
 cbmv2 = geomAndNot(via2_and1 ctm2)  /*  VIA2 locate on CBM */
 drc( ctmv2   sepNotch < 2.0  
	"MIMVIA.S.1  Min. space between two VIA2 on CTM >= 2.0um ")  
 drc( cbmv2   sepNotch < 4.0  
	"MIMVIA.S.2  Min. space between two VIA2 on M2 as MIM capacitor bottom metal >= 4.0um ")  
 drc( ctm2 via2  enc < 0.24  shielded withIntersection withSingularPoint 
	"MIMVIA.E.1  Min. extension of a CTM region beyond a VIA2 region >= 0.24um ")  
 errorLayer( geomStraddle( via2 ctm2  ) 
	"MIMVIA.E.1 2  Min. extension of a CTM region beyond a VIA2 region >= 0.24um ")  
 drc( bpm2c via1  enc < 0.12  shielded withIntersection 
	"MIMVIA.E.2  Min. extension of an M2 region as MIM capacitor bottom metal beyond a VIA1 or a VIA2 region >= 0.12um ")  
 drc( bpm2c via2  enc < 0.12  shielded withIntersection 
	"MIMVIA.E.2 2  Min. extension of an M2 region as MIM capacitor bottom metal beyond a VIA1 or a VIA2 region >= 0.12um ")  
 drc( via1 ctm2  sep < 0.4  shielded withIntersection withSingularPoint 
	"MIMVIA.C.1  Min. clearance of a VIA1 or a VIA2 to a CTM region >= 0.4um ")  
 drc( via2 ctm2  sep < 0.4  shielded withIntersection withSingularPoint 
	"MIMVIA.C.1 2  Min. clearance of a VIA1 or a VIA2 to a CTM region >= 0.4um ")  
geomConnect(
	buttOrOver(ctmv2 tctm)
)
processAntenna(
	gate((tctm ctmv2))
        antenna( ctmv2 )
        ratio = ctmv2.area/tctm.area
      drcAntenna( ctmv2 tctm ratio keep < 0.01  
	"MIMVIA.R.1  Min. density of VIA2 on CTM >= 1% ")
)
 errorLayer( geomAnd(via1 ctm2) 
	"MIMVIA.R.3  VIA1 under CTM region is not allowed ") 
if((THICK == 1) then
geomConnect(
	buttOrOver(ntapi nweli)
	buttOrOver(ntapi psdi)
	buttOrOver(ptapi nsdi)
	via(coi m1xd ilp1i ntapi ptapi psdi nsdi)
	via(via1i m1xd m2xd)
	via(viat m2xd m3xd)
	via(viac ctm2i m3xd)
	via(viadi m3xd mdxd)
)
/*  M3 checks */
/* ============= */
 drc( m3   width < 1.50  withCornerTouch 
	"UTM.W.1  Min. width of a M3 region >= 1.50um ")  
 drc( m3   sepNotch < 1.50  
	"UTM.S.1  Min. space between two M3 regions >= 1.50um ")  
 drc( m3 via2  enc < 0.3  shielded withIntersection withSingularPoint 
	"UTM.E.1  Min. extension of M3 region beyond VIA2 region >= 0.3um ")  
 errorLayer( geomAndNot(via2 m3) 
	"UTM.E.1 2  Min. extension of M3 region beyond VIA2 region >= 0.3um ") 
 utme2_x = drc( m3 via2  enc < 0.45  oppositeB shielded withIntersection edgeb )/*  a narrow side */
 utme2_x_ang01 = geomGetAngledEdge(utme2_x keep == 0)
 utme2_x_ang011 = geomGetAdjacentEdge(utme2_x utme2_x_ang01 )
 utme2_x_ang451 = geomGetAngledEdge(utme2_x keep == 45)
 errorLayer( geomAndNot(utme2_x_ang011 utme2_x_ang451) 
	"UTM.E.2  Min. extension of M3 region beyond VIA2 at the end of M3 >= 0.45um ") /*  adjacent narrow sides */
 utm_nind = geomAndNot(m3xd inddmy)  
utms2_utm_nind_s8 = geomGrow( utm_nind -8 -8 -8 -8 )
utms21_utm_nind_g8 = geomGrow( utms2_utm_nind_s8 8 8 8 8 )
 utms22_utm_nind_wide = geomAnd(utms21_utm_nind_g8 utm_nind)  
utms23_utm_nind_exp = geomSizeAndProc( utms22_utm_nind_wide utm_nind 1.05 1 )  
 utms24_utm_nind_branch = geomAndNot(utms23_utm_nind_exp utms22_utm_nind_wide)  
 utms25_utm_nind_branch_edge = geomGetEdge(utms24_utm_nind_branch coincident utm_nind)   
 utm_nind_exp_sz1 =  geomSize( utms23_utm_nind_exp 3.0 noClipAcute )   
 utms26_utm_nind_check = geomAnd(utm_nind utm_nind_exp_sz1)  
 utms27_utm_nind_branch_check0 = geomSize(utms25_utm_nind_branch_edge 3.0 edges)   
 utms28_utm_nind_branch_check1 = geomSize(utms25_utm_nind_branch_edge 0.005 edges)   
 utms29_utm_nind_branch_check2 = drc( utms28_utm_nind_branch_check1   sepNotch < 0.005  )
 utms210_utm_nind_branch_check3 = geomSize( utms29_utm_nind_branch_check2 (3.0-0.005 ) noClipAcute )   
 utm_nind_branch_check01 =  geomOr(utms27_utm_nind_branch_check0 utms210_utm_nind_branch_check3)  
 utms211_utm_nind_branch_check = geomAnd(utm_nind utm_nind_branch_check01)  
utms212_utm_nind_widec = geomCat( utms22_utm_nind_wide )
geomStamp(utms212_utm_nind_widec m3xd)  
utms213_utm_nind_checkc = geomCat( utms26_utm_nind_check )
geomStamp(utms213_utm_nind_checkc m3xd)  
utms214_utm_nind_branchc = geomCat( utms24_utm_nind_branch )
geomStamp(utms214_utm_nind_branchc m3xd)  
utms215_utm_nind_branch_checkc = geomCat( utms211_utm_nind_branch_check )
geomStamp(utms215_utm_nind_branch_checkc m3xd)  
 drc( utms212_utm_nind_widec utms213_utm_nind_checkc 0 < sep < 3.0  diffNet withIntersection 
	"UTM.S.2  Min. space between M3 metal lines with one or both metal width and length (>16um), >= 3um This check includes attached M3 metal extending 1um (exclude application for inductor) ")  
 drc( utms214_utm_nind_branchc utms215_utm_nind_branch_checkc 0 < sep < 3.0  diffNet withIntersection 
	"UTM.S.2 2  Min. space between M3 metal lines with one or both metal width and length (>16um), >= 3um This check includes attached M3 metal extending 1um (exclude application for inductor) ")  
 drc( m3  area < 2.25 
	"UTM.A.1  Min. area of M3 region >= 2.25um2 ") 
 utmr1_chip_nind = geomAndNot(chip inddmy)  
 utm_nind_den1 = drc(utm_nind utmr1_chip_nind 0 <=  coverage < 0.3 )
 errorLayer( geomGetCoverage( utm_nind_den1  0 <=  keep < 0.3  ) 
	"UTM.R.1  Min. density of M3 area >= 30% (exclude application for inductor) ") 

 inddmy_sz1 =  geomSize( inddmy -50.5 noClipAcute )   
 utmc1_ind_m3 = geomButtOrOver( m3 inddmy_sz1  )   
 utmc11_ind_m3v2 = geomButtOrOver( via2 utmc1_ind_m3  )   
 utmc12_ind_m2 = geomButtOrOver( m2 utmc11_ind_m3v2  )   
 utmc13_ind_m2v2 = geomButtOrOver( via2 utmc12_ind_m2  )   
 utmc14_ind_m3_conn = geomButtOrOver( m3 utmc13_ind_m2v2  )   
 utmc15_ind_m3_all = geomOr(utmc1_ind_m3 utmc14_ind_m3_conn)  
 utmc16_im3 = geomAnd(utmc15_ind_m3_all inddmy)  
 utmc17_rm3 = geomAndNot(m3 utmc15_ind_m3_all)  
 utmc18_om3 = geomAndNot(utmc15_ind_m3_all utmc16_im3)  
 drc( utmc17_rm3 utmc16_im3  sep < 50  shielded withIntersection withSingularPoint 
	"UTM.C.1  Min. clearance from one M3 as inductor to other M3 region >= 50um ")  
 drc( utmc16_im3 utmc18_om3 0 < sep < 50  shielded  app > 0 withIntersection 
	"UTM.C.1 2  Min. clearance from one M3 as inductor to other M3 region >= 50um ")  
 drc( inddmy m3 0 < enc < 50  shielded withIntersection withSingularPoint 
	"UTM.E.3  Min. extension of INDDMY beyond M3 region >= 50um ")  
 inddmyi = geomSize( inddmy -7 noClipAcute )  /*  exclude M1 substrate pick up node */ 
 indm = geomAnd(inddmy m1)  
 indme = geomGetEdge(indm coincident inddmy)   
 indme_sz1 = geomSize(indme 0.005 edges)
 inddmya = geomButtOrCoin( inddmy indme_sz1  keep < 2)   
 inddmy3 = geomEnclose( inddmya m2  )  /*  for 3 terminals inductor(central tap) */ 
 inddmy2 = geomAndNot(inddmy inddmy3)  /*  for 2 terminals inductor */
 errorLayer( geomAnd(inddmy2 m1) 
	"UTM.I.1  Via and metal inside INDDMY are not allowed, except underpass vias, metal interconnect, and the M1 substrate pick up node of the inductor ") 
 errorLayer( geomAnd(inddmy2 via1) 
	"UTM.I.1 2  Via and metal inside INDDMY are not allowed, except underpass vias, metal interconnect, and the M1 substrate pick up node of the inductor ") 
 errorLayer( geomAnd(inddmy nwel) 
	"UTM.I.2  Both active and passive devices are not allowed inside INDDMY, except substrate pick up node ") 
 errorLayer( geomAnd(inddmy poly) 
	"UTM.I.2 2  Both active and passive devices are not allowed inside INDDMY, except substrate pick up node ") 
 errorLayer( geomAnd(inddmyi od) 
	"UTM.I.2 3  Both active and passive devices are not allowed inside INDDMY, except substrate pick up node ") /*  exclude M1 substrate pick up node of inductor */
) ; 
 errorLayer( geomAnd(rlppdmy od) 
	"HRI.WARN  RLPPDMY overlap OD is not allowed ") 

)
